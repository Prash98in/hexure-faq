import {
  require_jsx_runtime
} from "./chunk-DT77FM6J.js";
import {
  require_Set,
  require_SetCache,
  require_Symbol,
  require_baseGetTag,
  require_cacheHas,
  require_isArray,
  require_isEqual,
  require_isObjectLike,
  require_setToArray
} from "./chunk-EJK6KD4L.js";
import {
  require_react
} from "./chunk-4D5CYJYK.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-CEQRFMJQ.js";

// node_modules/react-dnd/dist/esm/types/monitors.js
var init_monitors = __esm({
  "node_modules/react-dnd/dist/esm/types/monitors.js"() {
  }
});

// node_modules/react-dnd/dist/esm/types/options.js
var init_options = __esm({
  "node_modules/react-dnd/dist/esm/types/options.js"() {
  }
});

// node_modules/react-dnd/dist/esm/types/connectors.js
var init_connectors = __esm({
  "node_modules/react-dnd/dist/esm/types/connectors.js"() {
  }
});

// node_modules/react-dnd/dist/esm/types/index.js
var init_types = __esm({
  "node_modules/react-dnd/dist/esm/types/index.js"() {
    init_monitors();
    init_options();
    init_connectors();
  }
});

// node_modules/react-dnd/dist/esm/core/DndContext.js
var import_react, DndContext;
var init_DndContext = __esm({
  "node_modules/react-dnd/dist/esm/core/DndContext.js"() {
    import_react = __toESM(require_react());
    DndContext = (0, import_react.createContext)({
      dragDropManager: void 0
    });
  }
});

// node_modules/dnd-core/dist/esm/interfaces.js
var HandlerRole;
var init_interfaces = __esm({
  "node_modules/dnd-core/dist/esm/interfaces.js"() {
    (function(HandlerRole2) {
      HandlerRole2["SOURCE"] = "SOURCE";
      HandlerRole2["TARGET"] = "TARGET";
    })(HandlerRole || (HandlerRole = {}));
  }
});

// node_modules/@react-dnd/invariant/dist/invariant.esm.js
function invariant(condition, format) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
  if (true) {
    if (format === void 0) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    var error;
    if (format === void 0) {
      error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    } else {
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function() {
        return args[argIndex++];
      }));
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
}
var init_invariant_esm = __esm({
  "node_modules/@react-dnd/invariant/dist/invariant.esm.js"() {
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/types.js
var INIT_COORDS, BEGIN_DRAG, PUBLISH_DRAG_SOURCE, HOVER, DROP, END_DRAG;
var init_types2 = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/types.js"() {
    INIT_COORDS = "dnd-core/INIT_COORDS";
    BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
    PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
    HOVER = "dnd-core/HOVER";
    DROP = "dnd-core/DROP";
    END_DRAG = "dnd-core/END_DRAG";
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/local/setClientOffset.js
function setClientOffset(clientOffset, sourceClientOffset) {
  return {
    type: INIT_COORDS,
    payload: {
      sourceClientOffset: sourceClientOffset || null,
      clientOffset: clientOffset || null
    }
  };
}
var init_setClientOffset = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/local/setClientOffset.js"() {
    init_types2();
  }
});

// node_modules/dnd-core/dist/esm/utils/js_utils.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function get(obj, path, defaultValue) {
  return path.split(".").reduce(function(a, c) {
    return a && a[c] ? a[c] : defaultValue || null;
  }, obj);
}
function without(items2, item) {
  return items2.filter(function(i) {
    return i !== item;
  });
}
function isObject(input) {
  return _typeof(input) === "object";
}
function xor(itemsA, itemsB) {
  var map = /* @__PURE__ */ new Map();
  var insertItem = function insertItem2(item) {
    map.set(item, map.has(item) ? map.get(item) + 1 : 1);
  };
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  var result = [];
  map.forEach(function(count, key) {
    if (count === 1) {
      result.push(key);
    }
  });
  return result;
}
function intersection(itemsA, itemsB) {
  return itemsA.filter(function(t) {
    return itemsB.indexOf(t) > -1;
  });
}
var init_js_utils = __esm({
  "node_modules/dnd-core/dist/esm/utils/js_utils.js"() {
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/beginDrag.js
function createBeginDrag(manager) {
  return function beginDrag() {
    var sourceIds = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      publishSource: true
    };
    var _options$publishSourc = options.publishSource, publishSource = _options$publishSourc === void 0 ? true : _options$publishSourc, clientOffset = options.clientOffset, getSourceClientOffset2 = options.getSourceClientOffset;
    var monitor = manager.getMonitor();
    var registry = manager.getRegistry();
    manager.dispatch(setClientOffset(clientOffset));
    verifyInvariants(sourceIds, monitor, registry);
    var sourceId = getDraggableSource(sourceIds, monitor);
    if (sourceId === null) {
      manager.dispatch(ResetCoordinatesAction);
      return;
    }
    var sourceClientOffset = null;
    if (clientOffset) {
      if (!getSourceClientOffset2) {
        throw new Error("getSourceClientOffset must be defined");
      }
      verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
      sourceClientOffset = getSourceClientOffset2(sourceId);
    }
    manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
    var source = registry.getSource(sourceId);
    var item = source.beginDrag(monitor, sourceId);
    if (item == null) {
      return void 0;
    }
    verifyItemIsObject(item);
    registry.pinSource(sourceId);
    var itemType = registry.getSourceType(sourceId);
    return {
      type: BEGIN_DRAG,
      payload: {
        itemType,
        item,
        sourceId,
        clientOffset: clientOffset || null,
        sourceClientOffset: sourceClientOffset || null,
        isSourcePublic: !!publishSource
      }
    };
  };
}
function verifyInvariants(sourceIds, monitor, registry) {
  invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
  sourceIds.forEach(function(sourceId) {
    invariant(registry.getSource(sourceId), "Expected sourceIds to be registered.");
  });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
  invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function verifyItemIsObject(item) {
  invariant(isObject(item), "Item must be an object.");
}
function getDraggableSource(sourceIds, monitor) {
  var sourceId = null;
  for (var i = sourceIds.length - 1; i >= 0; i--) {
    if (monitor.canDragSource(sourceIds[i])) {
      sourceId = sourceIds[i];
      break;
    }
  }
  return sourceId;
}
var ResetCoordinatesAction;
var init_beginDrag = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/beginDrag.js"() {
    init_invariant_esm();
    init_setClientOffset();
    init_js_utils();
    init_types2();
    ResetCoordinatesAction = {
      type: INIT_COORDS,
      payload: {
        clientOffset: null,
        sourceClientOffset: null
      }
    };
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/publishDragSource.js
function createPublishDragSource(manager) {
  return function publishDragSource() {
    var monitor = manager.getMonitor();
    if (monitor.isDragging()) {
      return {
        type: PUBLISH_DRAG_SOURCE
      };
    }
  };
}
var init_publishDragSource = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/publishDragSource.js"() {
    init_types2();
  }
});

// node_modules/dnd-core/dist/esm/utils/matchesType.js
function matchesType(targetType, draggedItemType) {
  if (draggedItemType === null) {
    return targetType === null;
  }
  return Array.isArray(targetType) ? targetType.some(function(t) {
    return t === draggedItemType;
  }) : targetType === draggedItemType;
}
var init_matchesType = __esm({
  "node_modules/dnd-core/dist/esm/utils/matchesType.js"() {
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/hover.js
function createHover(manager) {
  return function hover(targetIdsArg) {
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, clientOffset = _ref.clientOffset;
    verifyTargetIdsIsArray(targetIdsArg);
    var targetIds = targetIdsArg.slice(0);
    var monitor = manager.getMonitor();
    var registry = manager.getRegistry();
    checkInvariants(targetIds, monitor, registry);
    var draggedItemType = monitor.getItemType();
    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
    hoverAllTargets(targetIds, monitor, registry);
    return {
      type: HOVER,
      payload: {
        targetIds,
        clientOffset: clientOffset || null
      }
    };
  };
}
function verifyTargetIdsIsArray(targetIdsArg) {
  invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
}
function checkInvariants(targetIds, monitor, registry) {
  invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call hover after drop.");
  for (var i = 0; i < targetIds.length; i++) {
    var targetId = targetIds[i];
    invariant(targetIds.lastIndexOf(targetId) === i, "Expected targetIds to be unique in the passed array.");
    var target = registry.getTarget(targetId);
    invariant(target, "Expected targetIds to be registered.");
  }
}
function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
  for (var i = targetIds.length - 1; i >= 0; i--) {
    var targetId = targetIds[i];
    var targetType = registry.getTargetType(targetId);
    if (!matchesType(targetType, draggedItemType)) {
      targetIds.splice(i, 1);
    }
  }
}
function hoverAllTargets(targetIds, monitor, registry) {
  targetIds.forEach(function(targetId) {
    var target = registry.getTarget(targetId);
    target.hover(monitor, targetId);
  });
}
var init_hover = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/hover.js"() {
    init_invariant_esm();
    init_matchesType();
    init_types2();
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/drop.js
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function createDrop(manager) {
  return function drop() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var monitor = manager.getMonitor();
    var registry = manager.getRegistry();
    verifyInvariants2(monitor);
    var targetIds = getDroppableTargets(monitor);
    targetIds.forEach(function(targetId, index) {
      var dropResult = determineDropResult(targetId, index, registry, monitor);
      var action = {
        type: DROP,
        payload: {
          dropResult: _objectSpread(_objectSpread({}, options), dropResult)
        }
      };
      manager.dispatch(action);
    });
  };
}
function verifyInvariants2(monitor) {
  invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
}
function determineDropResult(targetId, index, registry, monitor) {
  var target = registry.getTarget(targetId);
  var dropResult = target ? target.drop(monitor, targetId) : void 0;
  verifyDropResultType(dropResult);
  if (typeof dropResult === "undefined") {
    dropResult = index === 0 ? {} : monitor.getDropResult();
  }
  return dropResult;
}
function verifyDropResultType(dropResult) {
  invariant(typeof dropResult === "undefined" || isObject(dropResult), "Drop result must either be an object or undefined.");
}
function getDroppableTargets(monitor) {
  var targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
  targetIds.reverse();
  return targetIds;
}
var init_drop = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/drop.js"() {
    init_invariant_esm();
    init_types2();
    init_js_utils();
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/endDrag.js
function createEndDrag(manager) {
  return function endDrag() {
    var monitor = manager.getMonitor();
    var registry = manager.getRegistry();
    verifyIsDragging(monitor);
    var sourceId = monitor.getSourceId();
    if (sourceId != null) {
      var source = registry.getSource(sourceId, true);
      source.endDrag(monitor, sourceId);
      registry.unpinSource();
    }
    return {
      type: END_DRAG
    };
  };
}
function verifyIsDragging(monitor) {
  invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
}
var init_endDrag = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/endDrag.js"() {
    init_invariant_esm();
    init_types2();
  }
});

// node_modules/dnd-core/dist/esm/actions/dragDrop/index.js
function createDragDropActions(manager) {
  return {
    beginDrag: createBeginDrag(manager),
    publishDragSource: createPublishDragSource(manager),
    hover: createHover(manager),
    drop: createDrop(manager),
    endDrag: createEndDrag(manager)
  };
}
var init_dragDrop = __esm({
  "node_modules/dnd-core/dist/esm/actions/dragDrop/index.js"() {
    init_beginDrag();
    init_publishDragSource();
    init_hover();
    init_drop();
    init_endDrag();
    init_types2();
  }
});

// node_modules/dnd-core/dist/esm/classes/DragDropManagerImpl.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DragDropManagerImpl;
var init_DragDropManagerImpl = __esm({
  "node_modules/dnd-core/dist/esm/classes/DragDropManagerImpl.js"() {
    init_dragDrop();
    DragDropManagerImpl = function() {
      function DragDropManagerImpl2(store, monitor) {
        var _this = this;
        _classCallCheck(this, DragDropManagerImpl2);
        _defineProperty2(this, "store", void 0);
        _defineProperty2(this, "monitor", void 0);
        _defineProperty2(this, "backend", void 0);
        _defineProperty2(this, "isSetUp", false);
        _defineProperty2(this, "handleRefCountChange", function() {
          var shouldSetUp = _this.store.getState().refCount > 0;
          if (_this.backend) {
            if (shouldSetUp && !_this.isSetUp) {
              _this.backend.setup();
              _this.isSetUp = true;
            } else if (!shouldSetUp && _this.isSetUp) {
              _this.backend.teardown();
              _this.isSetUp = false;
            }
          }
        });
        this.store = store;
        this.monitor = monitor;
        store.subscribe(this.handleRefCountChange);
      }
      _createClass(DragDropManagerImpl2, [{
        key: "receiveBackend",
        value: function receiveBackend(backend) {
          this.backend = backend;
        }
      }, {
        key: "getMonitor",
        value: function getMonitor() {
          return this.monitor;
        }
      }, {
        key: "getBackend",
        value: function getBackend() {
          return this.backend;
        }
      }, {
        key: "getRegistry",
        value: function getRegistry() {
          return this.monitor.registry;
        }
      }, {
        key: "getActions",
        value: function getActions() {
          var manager = this;
          var dispatch = this.store.dispatch;
          function bindActionCreator(actionCreator) {
            return function() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              var action = actionCreator.apply(manager, args);
              if (typeof action !== "undefined") {
                dispatch(action);
              }
            };
          }
          var actions = createDragDropActions(this);
          return Object.keys(actions).reduce(function(boundActions, key) {
            var action = actions[key];
            boundActions[key] = bindActionCreator(action);
            return boundActions;
          }, {});
        }
      }, {
        key: "dispatch",
        value: function dispatch(action) {
          this.store.dispatch(action);
        }
      }]);
      return DragDropManagerImpl2;
    }();
  }
});

// node_modules/@babel/runtime/helpers/esm/typeof.js
var init_typeof = __esm({
  "node_modules/@babel/runtime/helpers/esm/typeof.js"() {
  }
});

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
var init_toPrimitive = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPrimitive.js"() {
    init_typeof();
  }
});

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
var init_toPropertyKey = __esm({
  "node_modules/@babel/runtime/helpers/esm/toPropertyKey.js"() {
    init_typeof();
    init_toPrimitive();
  }
});

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
var init_defineProperty = __esm({
  "node_modules/@babel/runtime/helpers/esm/defineProperty.js"() {
    init_toPropertyKey();
  }
});

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
var init_objectSpread2 = __esm({
  "node_modules/@babel/runtime/helpers/esm/objectSpread2.js"() {
    init_defineProperty();
  }
});

// node_modules/redux/es/redux.js
function isPlainObject(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  var typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
var $$observable, randomString, ActionTypes;
var init_redux = __esm({
  "node_modules/redux/es/redux.js"() {
    init_objectSpread2();
    $$observable = function() {
      return typeof Symbol === "function" && Symbol.observable || "@@observable";
    }();
    randomString = function randomString2() {
      return Math.random().toString(36).substring(7).split("").join(".");
    };
    ActionTypes = {
      INIT: "@@redux/INIT" + randomString(),
      REPLACE: "@@redux/REPLACE" + randomString(),
      PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
        return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
      }
    };
  }
});

// node_modules/dnd-core/dist/esm/utils/equality.js
function areCoordsEqual(offsetA, offsetB) {
  if (!offsetA && !offsetB) {
    return true;
  } else if (!offsetA || !offsetB) {
    return false;
  } else {
    return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
  }
}
function areArraysEqual(a, b) {
  var isEqual = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : strictEquality;
  if (a.length !== b.length) {
    return false;
  }
  for (var i = 0; i < a.length; ++i) {
    if (!isEqual(a[i], b[i])) {
      return false;
    }
  }
  return true;
}
var strictEquality;
var init_equality = __esm({
  "node_modules/dnd-core/dist/esm/utils/equality.js"() {
    strictEquality = function strictEquality2(a, b) {
      return a === b;
    };
  }
});

// node_modules/dnd-core/dist/esm/reducers/dragOffset.js
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty4(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function reduce() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  var payload = action.payload;
  switch (action.type) {
    case INIT_COORDS:
    case BEGIN_DRAG:
      return {
        initialSourceClientOffset: payload.sourceClientOffset,
        initialClientOffset: payload.clientOffset,
        clientOffset: payload.clientOffset
      };
    case HOVER:
      if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
        return state;
      }
      return _objectSpread3(_objectSpread3({}, state), {}, {
        clientOffset: payload.clientOffset
      });
    case END_DRAG:
    case DROP:
      return initialState;
    default:
      return state;
  }
}
var initialState;
var init_dragOffset = __esm({
  "node_modules/dnd-core/dist/esm/reducers/dragOffset.js"() {
    init_dragDrop();
    init_equality();
    initialState = {
      initialSourceClientOffset: null,
      initialClientOffset: null,
      clientOffset: null
    };
  }
});

// node_modules/dnd-core/dist/esm/actions/registry.js
function addSource(sourceId) {
  return {
    type: ADD_SOURCE,
    payload: {
      sourceId
    }
  };
}
function addTarget(targetId) {
  return {
    type: ADD_TARGET,
    payload: {
      targetId
    }
  };
}
function removeSource(sourceId) {
  return {
    type: REMOVE_SOURCE,
    payload: {
      sourceId
    }
  };
}
function removeTarget(targetId) {
  return {
    type: REMOVE_TARGET,
    payload: {
      targetId
    }
  };
}
var ADD_SOURCE, ADD_TARGET, REMOVE_SOURCE, REMOVE_TARGET;
var init_registry = __esm({
  "node_modules/dnd-core/dist/esm/actions/registry.js"() {
    ADD_SOURCE = "dnd-core/ADD_SOURCE";
    ADD_TARGET = "dnd-core/ADD_TARGET";
    REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
    REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
  }
});

// node_modules/dnd-core/dist/esm/reducers/dragOperation.js
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty5(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function reduce2() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : initialState2;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  var payload = action.payload;
  switch (action.type) {
    case BEGIN_DRAG:
      return _objectSpread4(_objectSpread4({}, state), {}, {
        itemType: payload.itemType,
        item: payload.item,
        sourceId: payload.sourceId,
        isSourcePublic: payload.isSourcePublic,
        dropResult: null,
        didDrop: false
      });
    case PUBLISH_DRAG_SOURCE:
      return _objectSpread4(_objectSpread4({}, state), {}, {
        isSourcePublic: true
      });
    case HOVER:
      return _objectSpread4(_objectSpread4({}, state), {}, {
        targetIds: payload.targetIds
      });
    case REMOVE_TARGET:
      if (state.targetIds.indexOf(payload.targetId) === -1) {
        return state;
      }
      return _objectSpread4(_objectSpread4({}, state), {}, {
        targetIds: without(state.targetIds, payload.targetId)
      });
    case DROP:
      return _objectSpread4(_objectSpread4({}, state), {}, {
        dropResult: payload.dropResult,
        didDrop: true,
        targetIds: []
      });
    case END_DRAG:
      return _objectSpread4(_objectSpread4({}, state), {}, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: false,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return state;
  }
}
var initialState2;
var init_dragOperation = __esm({
  "node_modules/dnd-core/dist/esm/reducers/dragOperation.js"() {
    init_dragDrop();
    init_registry();
    init_js_utils();
    initialState2 = {
      itemType: null,
      item: null,
      sourceId: null,
      targetIds: [],
      dropResult: null,
      didDrop: false,
      isSourcePublic: null
    };
  }
});

// node_modules/dnd-core/dist/esm/reducers/refCount.js
function reduce3() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  switch (action.type) {
    case ADD_SOURCE:
    case ADD_TARGET:
      return state + 1;
    case REMOVE_SOURCE:
    case REMOVE_TARGET:
      return state - 1;
    default:
      return state;
  }
}
var init_refCount = __esm({
  "node_modules/dnd-core/dist/esm/reducers/refCount.js"() {
    init_registry();
  }
});

// node_modules/dnd-core/dist/esm/utils/dirtiness.js
function areDirty(dirtyIds, handlerIds) {
  if (dirtyIds === NONE) {
    return false;
  }
  if (dirtyIds === ALL || typeof handlerIds === "undefined") {
    return true;
  }
  var commonIds = intersection(handlerIds, dirtyIds);
  return commonIds.length > 0;
}
var NONE, ALL;
var init_dirtiness = __esm({
  "node_modules/dnd-core/dist/esm/utils/dirtiness.js"() {
    init_js_utils();
    NONE = [];
    ALL = [];
    NONE.__IS_NONE__ = true;
    ALL.__IS_ALL__ = true;
  }
});

// node_modules/dnd-core/dist/esm/reducers/dirtyHandlerIds.js
function reduce4() {
  var _state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : NONE;
  var action = arguments.length > 1 ? arguments[1] : void 0;
  switch (action.type) {
    case HOVER:
      break;
    case ADD_SOURCE:
    case ADD_TARGET:
    case REMOVE_TARGET:
    case REMOVE_SOURCE:
      return NONE;
    case BEGIN_DRAG:
    case PUBLISH_DRAG_SOURCE:
    case END_DRAG:
    case DROP:
    default:
      return ALL;
  }
  var _action$payload = action.payload, _action$payload$targe = _action$payload.targetIds, targetIds = _action$payload$targe === void 0 ? [] : _action$payload$targe, _action$payload$prevT = _action$payload.prevTargetIds, prevTargetIds = _action$payload$prevT === void 0 ? [] : _action$payload$prevT;
  var result = xor(targetIds, prevTargetIds);
  var didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
  if (!didChange) {
    return NONE;
  }
  var prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
  var innermostTargetId = targetIds[targetIds.length - 1];
  if (prevInnermostTargetId !== innermostTargetId) {
    if (prevInnermostTargetId) {
      result.push(prevInnermostTargetId);
    }
    if (innermostTargetId) {
      result.push(innermostTargetId);
    }
  }
  return result;
}
var init_dirtyHandlerIds = __esm({
  "node_modules/dnd-core/dist/esm/reducers/dirtyHandlerIds.js"() {
    init_dragDrop();
    init_registry();
    init_equality();
    init_dirtiness();
    init_js_utils();
  }
});

// node_modules/dnd-core/dist/esm/reducers/stateId.js
function reduce5() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
  return state + 1;
}
var init_stateId = __esm({
  "node_modules/dnd-core/dist/esm/reducers/stateId.js"() {
  }
});

// node_modules/dnd-core/dist/esm/reducers/index.js
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys4(Object(source), true).forEach(function(key) {
        _defineProperty6(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function reduce6() {
  var state = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var action = arguments.length > 1 ? arguments[1] : void 0;
  return {
    dirtyHandlerIds: reduce4(state.dirtyHandlerIds, {
      type: action.type,
      payload: _objectSpread5(_objectSpread5({}, action.payload), {}, {
        prevTargetIds: get(state, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: reduce(state.dragOffset, action),
    refCount: reduce3(state.refCount, action),
    dragOperation: reduce2(state.dragOperation, action),
    stateId: reduce5(state.stateId)
  };
}
var init_reducers = __esm({
  "node_modules/dnd-core/dist/esm/reducers/index.js"() {
    init_dragOffset();
    init_dragOperation();
    init_refCount();
    init_dirtyHandlerIds();
    init_stateId();
    init_js_utils();
  }
});

// node_modules/dnd-core/dist/esm/utils/coords.js
function add(a, b) {
  return {
    x: a.x + b.x,
    y: a.y + b.y
  };
}
function subtract(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function getSourceClientOffset(state) {
  var clientOffset = state.clientOffset, initialClientOffset = state.initialClientOffset, initialSourceClientOffset = state.initialSourceClientOffset;
  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
    return null;
  }
  return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
}
function getDifferenceFromInitialOffset(state) {
  var clientOffset = state.clientOffset, initialClientOffset = state.initialClientOffset;
  if (!clientOffset || !initialClientOffset) {
    return null;
  }
  return subtract(clientOffset, initialClientOffset);
}
var init_coords = __esm({
  "node_modules/dnd-core/dist/esm/utils/coords.js"() {
  }
});

// node_modules/dnd-core/dist/esm/classes/DragDropMonitorImpl.js
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function _defineProperty7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DragDropMonitorImpl;
var init_DragDropMonitorImpl = __esm({
  "node_modules/dnd-core/dist/esm/classes/DragDropMonitorImpl.js"() {
    init_invariant_esm();
    init_matchesType();
    init_coords();
    init_dirtiness();
    DragDropMonitorImpl = function() {
      function DragDropMonitorImpl2(store, registry) {
        _classCallCheck2(this, DragDropMonitorImpl2);
        _defineProperty7(this, "store", void 0);
        _defineProperty7(this, "registry", void 0);
        this.store = store;
        this.registry = registry;
      }
      _createClass2(DragDropMonitorImpl2, [{
        key: "subscribeToStateChange",
        value: function subscribeToStateChange(listener) {
          var _this = this;
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            handlerIds: void 0
          };
          var handlerIds = options.handlerIds;
          invariant(typeof listener === "function", "listener must be a function.");
          invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
          var prevStateId = this.store.getState().stateId;
          var handleChange = function handleChange2() {
            var state = _this.store.getState();
            var currentStateId = state.stateId;
            try {
              var canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
              if (!canSkipListener) {
                listener();
              }
            } finally {
              prevStateId = currentStateId;
            }
          };
          return this.store.subscribe(handleChange);
        }
      }, {
        key: "subscribeToOffsetChange",
        value: function subscribeToOffsetChange(listener) {
          var _this2 = this;
          invariant(typeof listener === "function", "listener must be a function.");
          var previousState = this.store.getState().dragOffset;
          var handleChange = function handleChange2() {
            var nextState = _this2.store.getState().dragOffset;
            if (nextState === previousState) {
              return;
            }
            previousState = nextState;
            listener();
          };
          return this.store.subscribe(handleChange);
        }
      }, {
        key: "canDragSource",
        value: function canDragSource(sourceId) {
          if (!sourceId) {
            return false;
          }
          var source = this.registry.getSource(sourceId);
          invariant(source, "Expected to find a valid source. sourceId=".concat(sourceId));
          if (this.isDragging()) {
            return false;
          }
          return source.canDrag(this, sourceId);
        }
      }, {
        key: "canDropOnTarget",
        value: function canDropOnTarget(targetId) {
          if (!targetId) {
            return false;
          }
          var target = this.registry.getTarget(targetId);
          invariant(target, "Expected to find a valid target. targetId=".concat(targetId));
          if (!this.isDragging() || this.didDrop()) {
            return false;
          }
          var targetType = this.registry.getTargetType(targetId);
          var draggedItemType = this.getItemType();
          return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
        }
      }, {
        key: "isDragging",
        value: function isDragging() {
          return Boolean(this.getItemType());
        }
      }, {
        key: "isDraggingSource",
        value: function isDraggingSource(sourceId) {
          if (!sourceId) {
            return false;
          }
          var source = this.registry.getSource(sourceId, true);
          invariant(source, "Expected to find a valid source. sourceId=".concat(sourceId));
          if (!this.isDragging() || !this.isSourcePublic()) {
            return false;
          }
          var sourceType = this.registry.getSourceType(sourceId);
          var draggedItemType = this.getItemType();
          if (sourceType !== draggedItemType) {
            return false;
          }
          return source.isDragging(this, sourceId);
        }
      }, {
        key: "isOverTarget",
        value: function isOverTarget(targetId) {
          var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
            shallow: false
          };
          if (!targetId) {
            return false;
          }
          var shallow = options.shallow;
          if (!this.isDragging()) {
            return false;
          }
          var targetType = this.registry.getTargetType(targetId);
          var draggedItemType = this.getItemType();
          if (draggedItemType && !matchesType(targetType, draggedItemType)) {
            return false;
          }
          var targetIds = this.getTargetIds();
          if (!targetIds.length) {
            return false;
          }
          var index = targetIds.indexOf(targetId);
          if (shallow) {
            return index === targetIds.length - 1;
          } else {
            return index > -1;
          }
        }
      }, {
        key: "getItemType",
        value: function getItemType() {
          return this.store.getState().dragOperation.itemType;
        }
      }, {
        key: "getItem",
        value: function getItem() {
          return this.store.getState().dragOperation.item;
        }
      }, {
        key: "getSourceId",
        value: function getSourceId() {
          return this.store.getState().dragOperation.sourceId;
        }
      }, {
        key: "getTargetIds",
        value: function getTargetIds() {
          return this.store.getState().dragOperation.targetIds;
        }
      }, {
        key: "getDropResult",
        value: function getDropResult() {
          return this.store.getState().dragOperation.dropResult;
        }
      }, {
        key: "didDrop",
        value: function didDrop() {
          return this.store.getState().dragOperation.didDrop;
        }
      }, {
        key: "isSourcePublic",
        value: function isSourcePublic() {
          return Boolean(this.store.getState().dragOperation.isSourcePublic);
        }
      }, {
        key: "getInitialClientOffset",
        value: function getInitialClientOffset() {
          return this.store.getState().dragOffset.initialClientOffset;
        }
      }, {
        key: "getInitialSourceClientOffset",
        value: function getInitialSourceClientOffset() {
          return this.store.getState().dragOffset.initialSourceClientOffset;
        }
      }, {
        key: "getClientOffset",
        value: function getClientOffset() {
          return this.store.getState().dragOffset.clientOffset;
        }
      }, {
        key: "getSourceClientOffset",
        value: function getSourceClientOffset2() {
          return getSourceClientOffset(this.store.getState().dragOffset);
        }
      }, {
        key: "getDifferenceFromInitialOffset",
        value: function getDifferenceFromInitialOffset2() {
          return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
        }
      }]);
      return DragDropMonitorImpl2;
    }();
  }
});

// node_modules/dnd-core/dist/esm/utils/getNextUniqueId.js
function getNextUniqueId() {
  return nextUniqueId++;
}
var nextUniqueId;
var init_getNextUniqueId = __esm({
  "node_modules/dnd-core/dist/esm/utils/getNextUniqueId.js"() {
    nextUniqueId = 0;
  }
});

// node_modules/dnd-core/dist/esm/contracts.js
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}
function validateSourceContract(source) {
  invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
  invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
  invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
}
function validateTargetContract(target) {
  invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
  invariant(typeof target.hover === "function", "Expected hover to be a function.");
  invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
}
function validateType(type, allowArray) {
  if (allowArray && Array.isArray(type)) {
    type.forEach(function(t) {
      return validateType(t, false);
    });
    return;
  }
  invariant(typeof type === "string" || _typeof3(type) === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var init_contracts = __esm({
  "node_modules/dnd-core/dist/esm/contracts.js"() {
    init_invariant_esm();
  }
});

// node_modules/@react-dnd/asap/dist/esm/makeRequestCall.mjs
function makeRequestCallFromTimer(callback) {
  return function requestCall() {
    const timeoutHandle = setTimeout(handleTimer, 0);
    const intervalHandle = setInterval(handleTimer, 50);
    function handleTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      callback();
    }
  };
}
function makeRequestCallFromMutationObserver(callback) {
  let toggle = 1;
  const observer = new BrowserMutationObserver(callback);
  const node = document.createTextNode("");
  observer.observe(node, {
    characterData: true
  });
  return function requestCall() {
    toggle = -toggle;
    node.data = toggle;
  };
}
var scope, BrowserMutationObserver, makeRequestCall;
var init_makeRequestCall = __esm({
  "node_modules/@react-dnd/asap/dist/esm/makeRequestCall.mjs"() {
    scope = typeof global !== "undefined" ? global : self;
    BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
    makeRequestCall = typeof BrowserMutationObserver === "function" ? (
      // reliably everywhere they are implemented.
      // They are implemented in all modern browsers.
      //
      // - Android 4-4.3
      // - Chrome 26-34
      // - Firefox 14-29
      // - Internet Explorer 11
      // - iPad Safari 6-7.1
      // - iPhone Safari 7-7.1
      // - Safari 6-7
      makeRequestCallFromMutationObserver
    ) : (
      // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
      // 11-12, and in web workers in many engines.
      // Although message channels yield to any queued rendering and IO tasks, they
      // would be better than imposing the 4ms delay of timers.
      // However, they do not work reliably in Internet Explorer or Safari.
      // Internet Explorer 10 is the only browser that has setImmediate but does
      // not have MutationObservers.
      // Although setImmediate yields to the browser's renderer, it would be
      // preferrable to falling back to setTimeout since it does not have
      // the minimum 4ms penalty.
      // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
      // Desktop to a lesser extent) that renders both setImmediate and
      // MessageChannel useless for the purposes of ASAP.
      // https://github.com/kriskowal/q/issues/396
      // Timers are implemented universally.
      // We fall back to timers in workers in most engines, and in foreground
      // contexts in the following browsers.
      // However, note that even this simple case requires nuances to operate in a
      // broad spectrum of browsers.
      //
      // - Firefox 3-13
      // - Internet Explorer 6-9
      // - iPad Safari 4.3
      // - Lynx 2.8.7
      makeRequestCallFromTimer
    );
  }
});

// node_modules/@react-dnd/asap/dist/esm/AsapQueue.mjs
var AsapQueue;
var init_AsapQueue = __esm({
  "node_modules/@react-dnd/asap/dist/esm/AsapQueue.mjs"() {
    init_makeRequestCall();
    AsapQueue = class {
      // Use the fastest means possible to execute a task in its own turn, with
      // priority over other events including IO, animation, reflow, and redraw
      // events in browsers.
      //
      // An exception thrown by a task will permanently interrupt the processing of
      // subsequent tasks. The higher level `asap` function ensures that if an
      // exception is thrown by a task, that the task queue will continue flushing as
      // soon as possible, but if you use `rawAsap` directly, you are responsible to
      // either ensure that no exceptions are thrown from your task, or to manually
      // call `rawAsap.requestFlush` if an exception is thrown.
      enqueueTask(task) {
        const { queue: q, requestFlush } = this;
        if (!q.length) {
          requestFlush();
          this.flushing = true;
        }
        q[q.length] = task;
      }
      constructor() {
        this.queue = [];
        this.pendingErrors = [];
        this.flushing = false;
        this.index = 0;
        this.capacity = 1024;
        this.flush = () => {
          const { queue: q } = this;
          while (this.index < q.length) {
            const currentIndex = this.index;
            this.index++;
            q[currentIndex].call();
            if (this.index > this.capacity) {
              for (let scan = 0, newLength = q.length - this.index; scan < newLength; scan++) {
                q[scan] = q[scan + this.index];
              }
              q.length -= this.index;
              this.index = 0;
            }
          }
          q.length = 0;
          this.index = 0;
          this.flushing = false;
        };
        this.registerPendingError = (err) => {
          this.pendingErrors.push(err);
          this.requestErrorThrow();
        };
        this.requestFlush = makeRequestCall(this.flush);
        this.requestErrorThrow = makeRequestCallFromTimer(() => {
          if (this.pendingErrors.length) {
            throw this.pendingErrors.shift();
          }
        });
      }
    };
  }
});

// node_modules/@react-dnd/asap/dist/esm/RawTask.mjs
var RawTask;
var init_RawTask = __esm({
  "node_modules/@react-dnd/asap/dist/esm/RawTask.mjs"() {
    RawTask = class {
      call() {
        try {
          this.task && this.task();
        } catch (error) {
          this.onError(error);
        } finally {
          this.task = null;
          this.release(this);
        }
      }
      constructor(onError, release) {
        this.onError = onError;
        this.release = release;
        this.task = null;
      }
    };
  }
});

// node_modules/@react-dnd/asap/dist/esm/TaskFactory.mjs
var TaskFactory;
var init_TaskFactory = __esm({
  "node_modules/@react-dnd/asap/dist/esm/TaskFactory.mjs"() {
    init_RawTask();
    TaskFactory = class {
      create(task) {
        const tasks = this.freeTasks;
        const t1 = tasks.length ? tasks.pop() : new RawTask(
          this.onError,
          (t) => tasks[tasks.length] = t
        );
        t1.task = task;
        return t1;
      }
      constructor(onError) {
        this.onError = onError;
        this.freeTasks = [];
      }
    };
  }
});

// node_modules/@react-dnd/asap/dist/esm/asap.mjs
function asap(task) {
  asapQueue.enqueueTask(taskFactory.create(task));
}
var asapQueue, taskFactory;
var init_asap = __esm({
  "node_modules/@react-dnd/asap/dist/esm/asap.mjs"() {
    init_AsapQueue();
    init_TaskFactory();
    asapQueue = new AsapQueue();
    taskFactory = new TaskFactory(asapQueue.registerPendingError);
  }
});

// node_modules/@react-dnd/asap/dist/esm/types.mjs
var init_types3 = __esm({
  "node_modules/@react-dnd/asap/dist/esm/types.mjs"() {
  }
});

// node_modules/@react-dnd/asap/dist/esm/index.mjs
var init_esm = __esm({
  "node_modules/@react-dnd/asap/dist/esm/index.mjs"() {
    init_asap();
    init_types3();
    init_AsapQueue();
    init_TaskFactory();
  }
});

// node_modules/dnd-core/dist/esm/classes/HandlerRegistryImpl.js
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
function _defineProperty8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function getNextHandlerId(role) {
  var id = getNextUniqueId().toString();
  switch (role) {
    case HandlerRole.SOURCE:
      return "S".concat(id);
    case HandlerRole.TARGET:
      return "T".concat(id);
    default:
      throw new Error("Unknown Handler Role: ".concat(role));
  }
}
function parseRoleFromHandlerId(handlerId) {
  switch (handlerId[0]) {
    case "S":
      return HandlerRole.SOURCE;
    case "T":
      return HandlerRole.TARGET;
    default:
      invariant(false, "Cannot parse handler ID: ".concat(handlerId));
  }
}
function mapContainsValue(map, searchValue) {
  var entries = map.entries();
  var isDone = false;
  do {
    var _entries$next = entries.next(), done = _entries$next.done, _entries$next$value = _slicedToArray(_entries$next.value, 2), value = _entries$next$value[1];
    if (value === searchValue) {
      return true;
    }
    isDone = !!done;
  } while (!isDone);
  return false;
}
var HandlerRegistryImpl;
var init_HandlerRegistryImpl = __esm({
  "node_modules/dnd-core/dist/esm/classes/HandlerRegistryImpl.js"() {
    init_invariant_esm();
    init_registry();
    init_getNextUniqueId();
    init_interfaces();
    init_contracts();
    init_esm();
    HandlerRegistryImpl = function() {
      function HandlerRegistryImpl2(store) {
        _classCallCheck3(this, HandlerRegistryImpl2);
        _defineProperty8(this, "types", /* @__PURE__ */ new Map());
        _defineProperty8(this, "dragSources", /* @__PURE__ */ new Map());
        _defineProperty8(this, "dropTargets", /* @__PURE__ */ new Map());
        _defineProperty8(this, "pinnedSourceId", null);
        _defineProperty8(this, "pinnedSource", null);
        _defineProperty8(this, "store", void 0);
        this.store = store;
      }
      _createClass3(HandlerRegistryImpl2, [{
        key: "addSource",
        value: function addSource2(type, source) {
          validateType(type);
          validateSourceContract(source);
          var sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
          this.store.dispatch(addSource(sourceId));
          return sourceId;
        }
      }, {
        key: "addTarget",
        value: function addTarget2(type, target) {
          validateType(type, true);
          validateTargetContract(target);
          var targetId = this.addHandler(HandlerRole.TARGET, type, target);
          this.store.dispatch(addTarget(targetId));
          return targetId;
        }
      }, {
        key: "containsHandler",
        value: function containsHandler(handler) {
          return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
        }
      }, {
        key: "getSource",
        value: function getSource(sourceId) {
          var includePinned = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
          var isPinned = includePinned && sourceId === this.pinnedSourceId;
          var source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
          return source;
        }
      }, {
        key: "getTarget",
        value: function getTarget(targetId) {
          invariant(this.isTargetId(targetId), "Expected a valid target ID.");
          return this.dropTargets.get(targetId);
        }
      }, {
        key: "getSourceType",
        value: function getSourceType(sourceId) {
          invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
          return this.types.get(sourceId);
        }
      }, {
        key: "getTargetType",
        value: function getTargetType(targetId) {
          invariant(this.isTargetId(targetId), "Expected a valid target ID.");
          return this.types.get(targetId);
        }
      }, {
        key: "isSourceId",
        value: function isSourceId(handlerId) {
          var role = parseRoleFromHandlerId(handlerId);
          return role === HandlerRole.SOURCE;
        }
      }, {
        key: "isTargetId",
        value: function isTargetId(handlerId) {
          var role = parseRoleFromHandlerId(handlerId);
          return role === HandlerRole.TARGET;
        }
      }, {
        key: "removeSource",
        value: function removeSource2(sourceId) {
          var _this = this;
          invariant(this.getSource(sourceId), "Expected an existing source.");
          this.store.dispatch(removeSource(sourceId));
          asap(function() {
            _this.dragSources.delete(sourceId);
            _this.types.delete(sourceId);
          });
        }
      }, {
        key: "removeTarget",
        value: function removeTarget2(targetId) {
          invariant(this.getTarget(targetId), "Expected an existing target.");
          this.store.dispatch(removeTarget(targetId));
          this.dropTargets.delete(targetId);
          this.types.delete(targetId);
        }
      }, {
        key: "pinSource",
        value: function pinSource(sourceId) {
          var source = this.getSource(sourceId);
          invariant(source, "Expected an existing source.");
          this.pinnedSourceId = sourceId;
          this.pinnedSource = source;
        }
      }, {
        key: "unpinSource",
        value: function unpinSource() {
          invariant(this.pinnedSource, "No source is pinned at the time.");
          this.pinnedSourceId = null;
          this.pinnedSource = null;
        }
      }, {
        key: "addHandler",
        value: function addHandler(role, type, handler) {
          var id = getNextHandlerId(role);
          this.types.set(id, type);
          if (role === HandlerRole.SOURCE) {
            this.dragSources.set(id, handler);
          } else if (role === HandlerRole.TARGET) {
            this.dropTargets.set(id, handler);
          }
          return id;
        }
      }]);
      return HandlerRegistryImpl2;
    }();
  }
});

// node_modules/dnd-core/dist/esm/createDragDropManager.js
function createDragDropManager(backendFactory) {
  var globalContext = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
  var backendOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  var debugMode = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  var store = makeStoreInstance(debugMode);
  var monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
  var manager = new DragDropManagerImpl(store, monitor);
  var backend = backendFactory(manager, globalContext, backendOptions);
  manager.receiveBackend(backend);
  return manager;
}
function makeStoreInstance(debugMode) {
  var reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return createStore(reduce6, debugMode && reduxDevTools && reduxDevTools({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
var init_createDragDropManager = __esm({
  "node_modules/dnd-core/dist/esm/createDragDropManager.js"() {
    init_DragDropManagerImpl();
    init_redux();
    init_reducers();
    init_DragDropMonitorImpl();
    init_HandlerRegistryImpl();
  }
});

// node_modules/dnd-core/dist/esm/index.js
var init_esm2 = __esm({
  "node_modules/dnd-core/dist/esm/index.js"() {
    init_interfaces();
    init_createDragDropManager();
  }
});

// node_modules/react-dnd/dist/esm/core/DndProvider.js
function _slicedToArray2(arr, i) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i) || _unsupportedIterableToArray2(arr, i) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray2(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray2(o, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function getDndContextValue(props) {
  if ("manager" in props) {
    var _manager = {
      dragDropManager: props.manager
    };
    return [_manager, false];
  }
  var manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
  var isGlobalInstance = !props.context;
  return [manager, isGlobalInstance];
}
function createSingletonDndContext(backend) {
  var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : getGlobalContext();
  var options = arguments.length > 2 ? arguments[2] : void 0;
  var debugMode = arguments.length > 3 ? arguments[3] : void 0;
  var ctx = context;
  if (!ctx[INSTANCE_SYM]) {
    ctx[INSTANCE_SYM] = {
      dragDropManager: createDragDropManager(backend, context, options, debugMode)
    };
  }
  return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
  return typeof global !== "undefined" ? global : window;
}
var import_jsx_runtime, import_react2, _excluded, refCount, INSTANCE_SYM, DndProvider;
var init_DndProvider = __esm({
  "node_modules/react-dnd/dist/esm/core/DndProvider.js"() {
    import_jsx_runtime = __toESM(require_jsx_runtime());
    import_react2 = __toESM(require_react());
    init_esm2();
    init_DndContext();
    _excluded = ["children"];
    refCount = 0;
    INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
    DndProvider = (0, import_react2.memo)(function DndProvider2(_ref) {
      var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded);
      var _getDndContextValue = getDndContextValue(props), _getDndContextValue2 = _slicedToArray2(_getDndContextValue, 2), manager = _getDndContextValue2[0], isGlobalInstance = _getDndContextValue2[1];
      (0, import_react2.useEffect)(function() {
        if (isGlobalInstance) {
          var context = getGlobalContext();
          ++refCount;
          return function() {
            if (--refCount === 0) {
              context[INSTANCE_SYM] = null;
            }
          };
        }
      }, []);
      return (0, import_jsx_runtime.jsx)(DndContext.Provider, Object.assign({
        value: manager
      }, {
        children
      }), void 0);
    });
  }
});

// node_modules/react-dnd/dist/esm/core/DragPreviewImage.js
var import_react3, DragPreviewImage;
var init_DragPreviewImage = __esm({
  "node_modules/react-dnd/dist/esm/core/DragPreviewImage.js"() {
    import_react3 = __toESM(require_react());
    DragPreviewImage = (0, import_react3.memo)(function DragPreviewImage2(_ref) {
      var connect = _ref.connect, src = _ref.src;
      (0, import_react3.useEffect)(function() {
        if (typeof Image === "undefined")
          return;
        var connected = false;
        var img = new Image();
        img.src = src;
        img.onload = function() {
          connect(img);
          connected = true;
        };
        return function() {
          if (connected) {
            connect(null);
          }
        };
      });
      return null;
    });
  }
});

// node_modules/react-dnd/dist/esm/core/index.js
var init_core = __esm({
  "node_modules/react-dnd/dist/esm/core/index.js"() {
    init_DndContext();
    init_DndProvider();
    init_DragPreviewImage();
  }
});

// node_modules/react-dnd/dist/esm/internals/DragSourceMonitorImpl.js
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  return Constructor;
}
function _defineProperty9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var isCallingCanDrag, isCallingIsDragging, DragSourceMonitorImpl;
var init_DragSourceMonitorImpl = __esm({
  "node_modules/react-dnd/dist/esm/internals/DragSourceMonitorImpl.js"() {
    init_invariant_esm();
    isCallingCanDrag = false;
    isCallingIsDragging = false;
    DragSourceMonitorImpl = function() {
      function DragSourceMonitorImpl2(manager) {
        _classCallCheck4(this, DragSourceMonitorImpl2);
        _defineProperty9(this, "internalMonitor", void 0);
        _defineProperty9(this, "sourceId", null);
        this.internalMonitor = manager.getMonitor();
      }
      _createClass4(DragSourceMonitorImpl2, [{
        key: "receiveHandlerId",
        value: function receiveHandlerId(sourceId) {
          this.sourceId = sourceId;
        }
      }, {
        key: "getHandlerId",
        value: function getHandlerId() {
          return this.sourceId;
        }
      }, {
        key: "canDrag",
        value: function canDrag() {
          invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
          try {
            isCallingCanDrag = true;
            return this.internalMonitor.canDragSource(this.sourceId);
          } finally {
            isCallingCanDrag = false;
          }
        }
      }, {
        key: "isDragging",
        value: function isDragging() {
          if (!this.sourceId) {
            return false;
          }
          invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
          try {
            isCallingIsDragging = true;
            return this.internalMonitor.isDraggingSource(this.sourceId);
          } finally {
            isCallingIsDragging = false;
          }
        }
      }, {
        key: "subscribeToStateChange",
        value: function subscribeToStateChange(listener, options) {
          return this.internalMonitor.subscribeToStateChange(listener, options);
        }
      }, {
        key: "isDraggingSource",
        value: function isDraggingSource(sourceId) {
          return this.internalMonitor.isDraggingSource(sourceId);
        }
      }, {
        key: "isOverTarget",
        value: function isOverTarget(targetId, options) {
          return this.internalMonitor.isOverTarget(targetId, options);
        }
      }, {
        key: "getTargetIds",
        value: function getTargetIds() {
          return this.internalMonitor.getTargetIds();
        }
      }, {
        key: "isSourcePublic",
        value: function isSourcePublic() {
          return this.internalMonitor.isSourcePublic();
        }
      }, {
        key: "getSourceId",
        value: function getSourceId() {
          return this.internalMonitor.getSourceId();
        }
      }, {
        key: "subscribeToOffsetChange",
        value: function subscribeToOffsetChange(listener) {
          return this.internalMonitor.subscribeToOffsetChange(listener);
        }
      }, {
        key: "canDragSource",
        value: function canDragSource(sourceId) {
          return this.internalMonitor.canDragSource(sourceId);
        }
      }, {
        key: "canDropOnTarget",
        value: function canDropOnTarget(targetId) {
          return this.internalMonitor.canDropOnTarget(targetId);
        }
      }, {
        key: "getItemType",
        value: function getItemType() {
          return this.internalMonitor.getItemType();
        }
      }, {
        key: "getItem",
        value: function getItem() {
          return this.internalMonitor.getItem();
        }
      }, {
        key: "getDropResult",
        value: function getDropResult() {
          return this.internalMonitor.getDropResult();
        }
      }, {
        key: "didDrop",
        value: function didDrop() {
          return this.internalMonitor.didDrop();
        }
      }, {
        key: "getInitialClientOffset",
        value: function getInitialClientOffset() {
          return this.internalMonitor.getInitialClientOffset();
        }
      }, {
        key: "getInitialSourceClientOffset",
        value: function getInitialSourceClientOffset() {
          return this.internalMonitor.getInitialSourceClientOffset();
        }
      }, {
        key: "getSourceClientOffset",
        value: function getSourceClientOffset2() {
          return this.internalMonitor.getSourceClientOffset();
        }
      }, {
        key: "getClientOffset",
        value: function getClientOffset() {
          return this.internalMonitor.getClientOffset();
        }
      }, {
        key: "getDifferenceFromInitialOffset",
        value: function getDifferenceFromInitialOffset2() {
          return this.internalMonitor.getDifferenceFromInitialOffset();
        }
      }]);
      return DragSourceMonitorImpl2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/internals/DropTargetMonitorImpl.js
function _classCallCheck5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties5(Constructor, staticProps);
  return Constructor;
}
function _defineProperty10(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var isCallingCanDrop, DropTargetMonitorImpl;
var init_DropTargetMonitorImpl = __esm({
  "node_modules/react-dnd/dist/esm/internals/DropTargetMonitorImpl.js"() {
    init_invariant_esm();
    isCallingCanDrop = false;
    DropTargetMonitorImpl = function() {
      function DropTargetMonitorImpl2(manager) {
        _classCallCheck5(this, DropTargetMonitorImpl2);
        _defineProperty10(this, "internalMonitor", void 0);
        _defineProperty10(this, "targetId", null);
        this.internalMonitor = manager.getMonitor();
      }
      _createClass5(DropTargetMonitorImpl2, [{
        key: "receiveHandlerId",
        value: function receiveHandlerId(targetId) {
          this.targetId = targetId;
        }
      }, {
        key: "getHandlerId",
        value: function getHandlerId() {
          return this.targetId;
        }
      }, {
        key: "subscribeToStateChange",
        value: function subscribeToStateChange(listener, options) {
          return this.internalMonitor.subscribeToStateChange(listener, options);
        }
      }, {
        key: "canDrop",
        value: function canDrop() {
          if (!this.targetId) {
            return false;
          }
          invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
          try {
            isCallingCanDrop = true;
            return this.internalMonitor.canDropOnTarget(this.targetId);
          } finally {
            isCallingCanDrop = false;
          }
        }
      }, {
        key: "isOver",
        value: function isOver(options) {
          if (!this.targetId) {
            return false;
          }
          return this.internalMonitor.isOverTarget(this.targetId, options);
        }
      }, {
        key: "getItemType",
        value: function getItemType() {
          return this.internalMonitor.getItemType();
        }
      }, {
        key: "getItem",
        value: function getItem() {
          return this.internalMonitor.getItem();
        }
      }, {
        key: "getDropResult",
        value: function getDropResult() {
          return this.internalMonitor.getDropResult();
        }
      }, {
        key: "didDrop",
        value: function didDrop() {
          return this.internalMonitor.didDrop();
        }
      }, {
        key: "getInitialClientOffset",
        value: function getInitialClientOffset() {
          return this.internalMonitor.getInitialClientOffset();
        }
      }, {
        key: "getInitialSourceClientOffset",
        value: function getInitialSourceClientOffset() {
          return this.internalMonitor.getInitialSourceClientOffset();
        }
      }, {
        key: "getSourceClientOffset",
        value: function getSourceClientOffset2() {
          return this.internalMonitor.getSourceClientOffset();
        }
      }, {
        key: "getClientOffset",
        value: function getClientOffset() {
          return this.internalMonitor.getClientOffset();
        }
      }, {
        key: "getDifferenceFromInitialOffset",
        value: function getDifferenceFromInitialOffset2() {
          return this.internalMonitor.getDifferenceFromInitialOffset();
        }
      }]);
      return DropTargetMonitorImpl2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/internals/wrapConnectorHooks.js
function throwIfCompositeComponentElement(element) {
  if (typeof element.type === "string") {
    return;
  }
  var displayName = element.type.displayName || element.type.name || "the component";
  throw new Error("Only native element nodes can now be passed to React DnD connectors." + "You can either wrap ".concat(displayName, " into a <div>, or turn it into a ") + "drag source or a drop target itself.");
}
function wrapHookToRecognizeElement(hook) {
  return function() {
    var elementOrNode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
    if (!(0, import_react4.isValidElement)(elementOrNode)) {
      var node = elementOrNode;
      hook(node, options);
      return node;
    }
    var element = elementOrNode;
    throwIfCompositeComponentElement(element);
    var ref = options ? function(node2) {
      return hook(node2, options);
    } : hook;
    return cloneWithRef(element, ref);
  };
}
function wrapConnectorHooks(hooks) {
  var wrappedHooks = {};
  Object.keys(hooks).forEach(function(key) {
    var hook = hooks[key];
    if (key.endsWith("Ref")) {
      wrappedHooks[key] = hooks[key];
    } else {
      var wrappedHook = wrapHookToRecognizeElement(hook);
      wrappedHooks[key] = function() {
        return wrappedHook;
      };
    }
  });
  return wrappedHooks;
}
function setRef(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else {
    ref.current = node;
  }
}
function cloneWithRef(element, newRef) {
  var previousRef = element.ref;
  invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
  if (!previousRef) {
    return (0, import_react4.cloneElement)(element, {
      ref: newRef
    });
  } else {
    return (0, import_react4.cloneElement)(element, {
      ref: function ref(node) {
        setRef(previousRef, node);
        setRef(newRef, node);
      }
    });
  }
}
var import_react4;
var init_wrapConnectorHooks = __esm({
  "node_modules/react-dnd/dist/esm/internals/wrapConnectorHooks.js"() {
    init_invariant_esm();
    import_react4 = __toESM(require_react());
  }
});

// node_modules/react-dnd/dist/esm/internals/isRef.js
function _typeof4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof4 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof4 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof4(obj);
}
function isRef(obj) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    obj !== null && _typeof4(obj) === "object" && Object.prototype.hasOwnProperty.call(obj, "current")
  );
}
var init_isRef = __esm({
  "node_modules/react-dnd/dist/esm/internals/isRef.js"() {
  }
});

// node_modules/@react-dnd/shallowequal/dist/shallowequal.esm.js
function shallowEqual(objA, objB, compare, compareContext) {
  var compareResult = compare ? compare.call(compareContext, objA, objB) : void 0;
  if (compareResult !== void 0) {
    return !!compareResult;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    var valueA = objA[key];
    var valueB = objB[key];
    compareResult = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
    if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
var init_shallowequal_esm = __esm({
  "node_modules/@react-dnd/shallowequal/dist/shallowequal.esm.js"() {
  }
});

// node_modules/react-dnd/dist/esm/internals/SourceConnector.js
function _classCallCheck6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties6(Constructor, staticProps);
  return Constructor;
}
function _defineProperty11(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SourceConnector;
var init_SourceConnector = __esm({
  "node_modules/react-dnd/dist/esm/internals/SourceConnector.js"() {
    init_wrapConnectorHooks();
    init_isRef();
    init_shallowequal_esm();
    SourceConnector = function() {
      function SourceConnector2(backend) {
        var _this = this;
        _classCallCheck6(this, SourceConnector2);
        _defineProperty11(this, "hooks", wrapConnectorHooks({
          dragSource: function dragSource(node, options) {
            _this.clearDragSource();
            _this.dragSourceOptions = options || null;
            if (isRef(node)) {
              _this.dragSourceRef = node;
            } else {
              _this.dragSourceNode = node;
            }
            _this.reconnectDragSource();
          },
          dragPreview: function dragPreview(node, options) {
            _this.clearDragPreview();
            _this.dragPreviewOptions = options || null;
            if (isRef(node)) {
              _this.dragPreviewRef = node;
            } else {
              _this.dragPreviewNode = node;
            }
            _this.reconnectDragPreview();
          }
        }));
        _defineProperty11(this, "handlerId", null);
        _defineProperty11(this, "dragSourceRef", null);
        _defineProperty11(this, "dragSourceNode", void 0);
        _defineProperty11(this, "dragSourceOptionsInternal", null);
        _defineProperty11(this, "dragSourceUnsubscribe", void 0);
        _defineProperty11(this, "dragPreviewRef", null);
        _defineProperty11(this, "dragPreviewNode", void 0);
        _defineProperty11(this, "dragPreviewOptionsInternal", null);
        _defineProperty11(this, "dragPreviewUnsubscribe", void 0);
        _defineProperty11(this, "lastConnectedHandlerId", null);
        _defineProperty11(this, "lastConnectedDragSource", null);
        _defineProperty11(this, "lastConnectedDragSourceOptions", null);
        _defineProperty11(this, "lastConnectedDragPreview", null);
        _defineProperty11(this, "lastConnectedDragPreviewOptions", null);
        _defineProperty11(this, "backend", void 0);
        this.backend = backend;
      }
      _createClass6(SourceConnector2, [{
        key: "receiveHandlerId",
        value: function receiveHandlerId(newHandlerId) {
          if (this.handlerId === newHandlerId) {
            return;
          }
          this.handlerId = newHandlerId;
          this.reconnect();
        }
      }, {
        key: "connectTarget",
        get: function get2() {
          return this.dragSource;
        }
      }, {
        key: "dragSourceOptions",
        get: function get2() {
          return this.dragSourceOptionsInternal;
        },
        set: function set(options) {
          this.dragSourceOptionsInternal = options;
        }
      }, {
        key: "dragPreviewOptions",
        get: function get2() {
          return this.dragPreviewOptionsInternal;
        },
        set: function set(options) {
          this.dragPreviewOptionsInternal = options;
        }
      }, {
        key: "reconnect",
        value: function reconnect() {
          this.reconnectDragSource();
          this.reconnectDragPreview();
        }
      }, {
        key: "reconnectDragSource",
        value: function reconnectDragSource() {
          var dragSource = this.dragSource;
          var didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
          if (didChange) {
            this.disconnectDragSource();
          }
          if (!this.handlerId) {
            return;
          }
          if (!dragSource) {
            this.lastConnectedDragSource = dragSource;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragSource = dragSource;
            this.lastConnectedDragSourceOptions = this.dragSourceOptions;
            this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
          }
        }
      }, {
        key: "reconnectDragPreview",
        value: function reconnectDragPreview() {
          var dragPreview = this.dragPreview;
          var didChange = this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
          if (didChange) {
            this.disconnectDragPreview();
          }
          if (!this.handlerId) {
            return;
          }
          if (!dragPreview) {
            this.lastConnectedDragPreview = dragPreview;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDragPreview = dragPreview;
            this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
            this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
          }
        }
      }, {
        key: "didHandlerIdChange",
        value: function didHandlerIdChange() {
          return this.lastConnectedHandlerId !== this.handlerId;
        }
      }, {
        key: "didConnectedDragSourceChange",
        value: function didConnectedDragSourceChange() {
          return this.lastConnectedDragSource !== this.dragSource;
        }
      }, {
        key: "didConnectedDragPreviewChange",
        value: function didConnectedDragPreviewChange() {
          return this.lastConnectedDragPreview !== this.dragPreview;
        }
      }, {
        key: "didDragSourceOptionsChange",
        value: function didDragSourceOptionsChange() {
          return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
        }
      }, {
        key: "didDragPreviewOptionsChange",
        value: function didDragPreviewOptionsChange() {
          return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
        }
      }, {
        key: "disconnectDragSource",
        value: function disconnectDragSource() {
          if (this.dragSourceUnsubscribe) {
            this.dragSourceUnsubscribe();
            this.dragSourceUnsubscribe = void 0;
          }
        }
      }, {
        key: "disconnectDragPreview",
        value: function disconnectDragPreview() {
          if (this.dragPreviewUnsubscribe) {
            this.dragPreviewUnsubscribe();
            this.dragPreviewUnsubscribe = void 0;
            this.dragPreviewNode = null;
            this.dragPreviewRef = null;
          }
        }
      }, {
        key: "dragSource",
        get: function get2() {
          return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
        }
      }, {
        key: "dragPreview",
        get: function get2() {
          return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
        }
      }, {
        key: "clearDragSource",
        value: function clearDragSource() {
          this.dragSourceNode = null;
          this.dragSourceRef = null;
        }
      }, {
        key: "clearDragPreview",
        value: function clearDragPreview() {
          this.dragPreviewNode = null;
          this.dragPreviewRef = null;
        }
      }]);
      return SourceConnector2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/internals/TargetConnector.js
function _classCallCheck7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties7(Constructor, staticProps);
  return Constructor;
}
function _defineProperty12(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TargetConnector;
var init_TargetConnector = __esm({
  "node_modules/react-dnd/dist/esm/internals/TargetConnector.js"() {
    init_shallowequal_esm();
    init_wrapConnectorHooks();
    init_isRef();
    TargetConnector = function() {
      function TargetConnector2(backend) {
        var _this = this;
        _classCallCheck7(this, TargetConnector2);
        _defineProperty12(this, "hooks", wrapConnectorHooks({
          dropTarget: function dropTarget(node, options) {
            _this.clearDropTarget();
            _this.dropTargetOptions = options;
            if (isRef(node)) {
              _this.dropTargetRef = node;
            } else {
              _this.dropTargetNode = node;
            }
            _this.reconnect();
          }
        }));
        _defineProperty12(this, "handlerId", null);
        _defineProperty12(this, "dropTargetRef", null);
        _defineProperty12(this, "dropTargetNode", void 0);
        _defineProperty12(this, "dropTargetOptionsInternal", null);
        _defineProperty12(this, "unsubscribeDropTarget", void 0);
        _defineProperty12(this, "lastConnectedHandlerId", null);
        _defineProperty12(this, "lastConnectedDropTarget", null);
        _defineProperty12(this, "lastConnectedDropTargetOptions", null);
        _defineProperty12(this, "backend", void 0);
        this.backend = backend;
      }
      _createClass7(TargetConnector2, [{
        key: "connectTarget",
        get: function get2() {
          return this.dropTarget;
        }
      }, {
        key: "reconnect",
        value: function reconnect() {
          var didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
          if (didChange) {
            this.disconnectDropTarget();
          }
          var dropTarget = this.dropTarget;
          if (!this.handlerId) {
            return;
          }
          if (!dropTarget) {
            this.lastConnectedDropTarget = dropTarget;
            return;
          }
          if (didChange) {
            this.lastConnectedHandlerId = this.handlerId;
            this.lastConnectedDropTarget = dropTarget;
            this.lastConnectedDropTargetOptions = this.dropTargetOptions;
            this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
          }
        }
      }, {
        key: "receiveHandlerId",
        value: function receiveHandlerId(newHandlerId) {
          if (newHandlerId === this.handlerId) {
            return;
          }
          this.handlerId = newHandlerId;
          this.reconnect();
        }
      }, {
        key: "dropTargetOptions",
        get: function get2() {
          return this.dropTargetOptionsInternal;
        },
        set: function set(options) {
          this.dropTargetOptionsInternal = options;
        }
      }, {
        key: "didHandlerIdChange",
        value: function didHandlerIdChange() {
          return this.lastConnectedHandlerId !== this.handlerId;
        }
      }, {
        key: "didDropTargetChange",
        value: function didDropTargetChange() {
          return this.lastConnectedDropTarget !== this.dropTarget;
        }
      }, {
        key: "didOptionsChange",
        value: function didOptionsChange() {
          return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
        }
      }, {
        key: "disconnectDropTarget",
        value: function disconnectDropTarget() {
          if (this.unsubscribeDropTarget) {
            this.unsubscribeDropTarget();
            this.unsubscribeDropTarget = void 0;
          }
        }
      }, {
        key: "dropTarget",
        get: function get2() {
          return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
        }
      }, {
        key: "clearDropTarget",
        value: function clearDropTarget() {
          this.dropTargetRef = null;
          this.dropTargetNode = null;
        }
      }]);
      return TargetConnector2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/internals/registration.js
function registerTarget(type, target, manager) {
  var registry = manager.getRegistry();
  var targetId = registry.addTarget(type, target);
  return [targetId, function() {
    return registry.removeTarget(targetId);
  }];
}
function registerSource(type, source, manager) {
  var registry = manager.getRegistry();
  var sourceId = registry.addSource(type, source);
  return [sourceId, function() {
    return registry.removeSource(sourceId);
  }];
}
var init_registration = __esm({
  "node_modules/react-dnd/dist/esm/internals/registration.js"() {
  }
});

// node_modules/react-dnd/dist/esm/internals/index.js
var init_internals = __esm({
  "node_modules/react-dnd/dist/esm/internals/index.js"() {
    init_DragSourceMonitorImpl();
    init_DropTargetMonitorImpl();
    init_SourceConnector();
    init_TargetConnector();
    init_registration();
  }
});

// node_modules/react-dnd/dist/esm/decorators/utils.js
function _typeof5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof5 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof5 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof5(obj);
}
function getDecoratedComponent(instanceRef) {
  var currentRef = instanceRef.current;
  if (currentRef == null) {
    return null;
  } else if (currentRef.decoratedRef) {
    return currentRef.decoratedRef.current;
  } else {
    return currentRef;
  }
}
function isClassComponent(Component3) {
  return Component3 && Component3.prototype && typeof Component3.prototype.render === "function";
}
function isRefForwardingComponent(C) {
  var _item$$$typeof;
  var item = C;
  return (item === null || item === void 0 ? void 0 : (_item$$$typeof = item.$$typeof) === null || _item$$$typeof === void 0 ? void 0 : _item$$$typeof.toString()) === "Symbol(react.forward_ref)";
}
function isRefable(C) {
  return isClassComponent(C) || isRefForwardingComponent(C);
}
function checkDecoratorArguments(functionName, signature) {
  if (true) {
    for (var i = 0; i < (arguments.length <= 2 ? 0 : arguments.length - 2); i++) {
      var arg = i + 2 < 2 || arguments.length <= i + 2 ? void 0 : arguments[i + 2];
      if (arg && arg.prototype && arg.prototype.render) {
        console.error("You seem to be applying the arguments in the wrong order. " + "It should be ".concat(functionName, "(").concat(signature, ")(Component), not the other way around. ") + "Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#you-seem-to-be-applying-the-arguments-in-the-wrong-order");
        return;
      }
    }
  }
}
function isFunction(input) {
  return typeof input === "function";
}
function noop() {
}
function isObjectLike(input) {
  return _typeof5(input) === "object" && input !== null;
}
function isPlainObject2(input) {
  if (!isObjectLike(input)) {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  var proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
function isValidType(type, allowArray) {
  return typeof type === "string" || _typeof5(type) === "symbol" || !!allowArray && Array.isArray(type) && type.every(function(t) {
    return isValidType(t, false);
  });
}
var init_utils = __esm({
  "node_modules/react-dnd/dist/esm/decorators/utils.js"() {
  }
});

// node_modules/react-dnd/dist/esm/decorators/disposables.js
function _classCallCheck8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties8(Constructor, staticProps);
  return Constructor;
}
function _defineProperty13(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Disposable, CompositeDisposable, SerialDisposable;
var init_disposables = __esm({
  "node_modules/react-dnd/dist/esm/decorators/disposables.js"() {
    init_utils();
    Disposable = function() {
      function Disposable2(action) {
        _classCallCheck8(this, Disposable2);
        _defineProperty13(this, "isDisposed", false);
        _defineProperty13(this, "action", void 0);
        this.action = isFunction(action) ? action : noop;
      }
      _createClass8(Disposable2, [{
        key: "dispose",
        value: function dispose() {
          if (!this.isDisposed) {
            this.action();
            this.isDisposed = true;
          }
        }
      }], [{
        key: "isDisposable",
        value: (
          /**
           * Gets the disposable that does nothing when disposed.
           */
          /**
           * Validates whether the given object is a disposable
           * @param {Object} Object to test whether it has a dispose method
           * @returns {Boolean} true if a disposable object, else false.
           */
          function isDisposable(d) {
            return Boolean(d && isFunction(d.dispose));
          }
        )
      }, {
        key: "_fixup",
        value: function _fixup(result) {
          return Disposable2.isDisposable(result) ? result : Disposable2.empty;
        }
        /**
         * Creates a disposable object that invokes the specified action when disposed.
         * @param {Function} dispose Action to run during the first call to dispose.
         * The action is guaranteed to be run at most once.
         * @return {Disposable} The disposable object that runs the given action upon disposal.
         */
      }, {
        key: "create",
        value: function create(action) {
          return new Disposable2(action);
        }
      }]);
      return Disposable2;
    }();
    _defineProperty13(Disposable, "empty", {
      dispose: noop
    });
    CompositeDisposable = function() {
      function CompositeDisposable2() {
        _classCallCheck8(this, CompositeDisposable2);
        _defineProperty13(this, "isDisposed", false);
        _defineProperty13(this, "disposables", void 0);
        for (var _len = arguments.length, disposables = new Array(_len), _key = 0; _key < _len; _key++) {
          disposables[_key] = arguments[_key];
        }
        this.disposables = disposables;
      }
      _createClass8(CompositeDisposable2, [{
        key: "add",
        value: function add2(item) {
          if (this.isDisposed) {
            item.dispose();
          } else {
            this.disposables.push(item);
          }
        }
        /**
         * Removes and disposes the first occurrence of a disposable from the CompositeDisposable.
         * @param {Any} item Disposable to remove.
         * @returns {Boolean} true if found; false otherwise.
         */
      }, {
        key: "remove",
        value: function remove(item) {
          var shouldDispose = false;
          if (!this.isDisposed) {
            var idx = this.disposables.indexOf(item);
            if (idx !== -1) {
              shouldDispose = true;
              this.disposables.splice(idx, 1);
              item.dispose();
            }
          }
          return shouldDispose;
        }
        /**
         *  Disposes all disposables in the group and removes them from the group but
         *  does not dispose the CompositeDisposable.
         */
      }, {
        key: "clear",
        value: function clear() {
          if (!this.isDisposed) {
            var len = this.disposables.length;
            var currentDisposables = new Array(len);
            for (var i = 0; i < len; i++) {
              currentDisposables[i] = this.disposables[i];
            }
            this.disposables = [];
            for (var _i = 0; _i < len; _i++) {
              currentDisposables[_i].dispose();
            }
          }
        }
        /**
         *  Disposes all disposables in the group and removes them from the group.
         */
      }, {
        key: "dispose",
        value: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            var len = this.disposables.length;
            var currentDisposables = new Array(len);
            for (var i = 0; i < len; i++) {
              currentDisposables[i] = this.disposables[i];
            }
            this.disposables = [];
            for (var _i2 = 0; _i2 < len; _i2++) {
              currentDisposables[_i2].dispose();
            }
          }
        }
      }]);
      return CompositeDisposable2;
    }();
    SerialDisposable = function() {
      function SerialDisposable2() {
        _classCallCheck8(this, SerialDisposable2);
        _defineProperty13(this, "isDisposed", false);
        _defineProperty13(this, "current", void 0);
      }
      _createClass8(SerialDisposable2, [{
        key: "getDisposable",
        value: (
          /**
           * Gets the underlying disposable.
           * @returns {Any} the underlying disposable.
           */
          function getDisposable() {
            return this.current;
          }
        )
      }, {
        key: "setDisposable",
        value: function setDisposable(value) {
          var shouldDispose = this.isDisposed;
          if (!shouldDispose) {
            var old = this.current;
            this.current = value;
            if (old) {
              old.dispose();
            }
          }
          if (shouldDispose && value) {
            value.dispose();
          }
        }
        /** Performs the task of cleaning up resources. */
      }, {
        key: "dispose",
        value: function dispose() {
          if (!this.isDisposed) {
            this.isDisposed = true;
            var old = this.current;
            this.current = void 0;
            if (old) {
              old.dispose();
            }
          }
        }
      }]);
      return SerialDisposable2;
    }();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i = 0; i < keys.length; ++i) {
          var key = keys[i];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// node_modules/react-dnd/dist/esm/decorators/decorateHandler.js
function _typeof6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof6 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof6 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof6(obj);
}
function _slicedToArray3(arr, i) {
  return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i) || _unsupportedIterableToArray3(arr, i) || _nonIterableRest3();
}
function _nonIterableRest3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray3(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray3(o, minLen);
}
function _arrayLikeToArray3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit3(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _classCallCheck9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties9(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof6(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty14(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function decorateHandler(_ref) {
  var DecoratedComponent = _ref.DecoratedComponent, createHandler = _ref.createHandler, createMonitor = _ref.createMonitor, createConnector = _ref.createConnector, registerHandler = _ref.registerHandler, containerDisplayName = _ref.containerDisplayName, getType = _ref.getType, collect = _ref.collect, options = _ref.options;
  var _options$arePropsEqua = options.arePropsEqual, arePropsEqual = _options$arePropsEqua === void 0 ? shallowEqual : _options$arePropsEqua;
  var Decorated = DecoratedComponent;
  var displayName = DecoratedComponent.displayName || DecoratedComponent.name || "Component";
  var DragDropContainer = function(_Component) {
    _inherits(DragDropContainer2, _Component);
    var _super = _createSuper(DragDropContainer2);
    function DragDropContainer2(props) {
      var _this;
      _classCallCheck9(this, DragDropContainer2);
      _this = _super.call(this, props);
      _defineProperty14(_assertThisInitialized(_this), "decoratedRef", (0, import_react5.createRef)());
      _defineProperty14(_assertThisInitialized(_this), "handlerId", void 0);
      _defineProperty14(_assertThisInitialized(_this), "manager", void 0);
      _defineProperty14(_assertThisInitialized(_this), "handlerMonitor", void 0);
      _defineProperty14(_assertThisInitialized(_this), "handlerConnector", void 0);
      _defineProperty14(_assertThisInitialized(_this), "handler", void 0);
      _defineProperty14(_assertThisInitialized(_this), "disposable", void 0);
      _defineProperty14(_assertThisInitialized(_this), "currentType", void 0);
      _defineProperty14(_assertThisInitialized(_this), "handleChange", function() {
        var nextState = _this.getCurrentState();
        if (!shallowEqual(nextState, _this.state)) {
          _this.setState(nextState);
        }
      });
      _this.disposable = new SerialDisposable();
      _this.receiveProps(props);
      _this.dispose();
      return _this;
    }
    _createClass9(DragDropContainer2, [{
      key: "getHandlerId",
      value: function getHandlerId() {
        return this.handlerId;
      }
    }, {
      key: "getDecoratedComponentInstance",
      value: function getDecoratedComponentInstance() {
        invariant(this.decoratedRef.current, "In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()");
        return this.decoratedRef.current;
      }
    }, {
      key: "shouldComponentUpdate",
      value: function shouldComponentUpdate(nextProps, nextState) {
        return !arePropsEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
      }
    }, {
      key: "componentDidMount",
      value: function componentDidMount() {
        this.disposable = new SerialDisposable();
        this.currentType = void 0;
        this.receiveProps(this.props);
        this.handleChange();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (!arePropsEqual(this.props, prevProps)) {
          this.receiveProps(this.props);
          this.handleChange();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.dispose();
      }
    }, {
      key: "receiveProps",
      value: function receiveProps(props) {
        if (!this.handler) {
          return;
        }
        this.handler.receiveProps(props);
        this.receiveType(getType(props));
      }
    }, {
      key: "receiveType",
      value: function receiveType(type) {
        if (!this.handlerMonitor || !this.manager || !this.handlerConnector) {
          return;
        }
        if (type === this.currentType) {
          return;
        }
        this.currentType = type;
        var _registerHandler = registerHandler(type, this.handler, this.manager), _registerHandler2 = _slicedToArray3(_registerHandler, 2), handlerId = _registerHandler2[0], unregister = _registerHandler2[1];
        this.handlerId = handlerId;
        this.handlerMonitor.receiveHandlerId(handlerId);
        this.handlerConnector.receiveHandlerId(handlerId);
        var globalMonitor = this.manager.getMonitor();
        var unsubscribe = globalMonitor.subscribeToStateChange(this.handleChange, {
          handlerIds: [handlerId]
        });
        this.disposable.setDisposable(new CompositeDisposable(new Disposable(unsubscribe), new Disposable(unregister)));
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.disposable.dispose();
        if (this.handlerConnector) {
          this.handlerConnector.receiveHandlerId(null);
        }
      }
    }, {
      key: "getCurrentState",
      value: function getCurrentState() {
        if (!this.handlerConnector) {
          return {};
        }
        var nextState = collect(this.handlerConnector.hooks, this.handlerMonitor, this.props);
        if (true) {
          invariant(isPlainObject2(nextState), "Expected `collect` specified as the second argument to %s for %s to return a plain object of props to inject. Instead, received %s.", containerDisplayName, displayName, nextState);
        }
        return nextState;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        return (0, import_jsx_runtime2.jsx)(DndContext.Consumer, {
          children: function children(_ref2) {
            var dragDropManager = _ref2.dragDropManager;
            _this2.receiveDragDropManager(dragDropManager);
            if (typeof requestAnimationFrame !== "undefined") {
              requestAnimationFrame(function() {
                var _this2$handlerConnect;
                return (_this2$handlerConnect = _this2.handlerConnector) === null || _this2$handlerConnect === void 0 ? void 0 : _this2$handlerConnect.reconnect();
              });
            }
            return (0, import_jsx_runtime2.jsx)(Decorated, Object.assign({}, _this2.props, _this2.getCurrentState(), {
              // NOTE: if Decorated is a Function Component, decoratedRef will not be populated unless it's a refforwarding component.
              ref: isRefable(Decorated) ? _this2.decoratedRef : null
            }), void 0);
          }
        }, void 0);
      }
    }, {
      key: "receiveDragDropManager",
      value: function receiveDragDropManager(dragDropManager) {
        if (this.manager !== void 0) {
          return;
        }
        invariant(dragDropManager !== void 0, "Could not find the drag and drop manager in the context of %s. Make sure to render a DndProvider component in your top-level component. Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#could-not-find-the-drag-and-drop-manager-in-the-context", displayName, displayName);
        if (dragDropManager === void 0) {
          return;
        }
        this.manager = dragDropManager;
        this.handlerMonitor = createMonitor(dragDropManager);
        this.handlerConnector = createConnector(dragDropManager.getBackend());
        this.handler = createHandler(this.handlerMonitor, this.decoratedRef);
      }
    }]);
    return DragDropContainer2;
  }(import_react5.Component);
  _defineProperty14(DragDropContainer, "DecoratedComponent", DecoratedComponent);
  _defineProperty14(DragDropContainer, "displayName", "".concat(containerDisplayName, "(").concat(displayName, ")"));
  return (0, import_hoist_non_react_statics.default)(DragDropContainer, DecoratedComponent);
}
var import_jsx_runtime2, import_react5, import_hoist_non_react_statics;
var init_decorateHandler = __esm({
  "node_modules/react-dnd/dist/esm/decorators/decorateHandler.js"() {
    import_jsx_runtime2 = __toESM(require_jsx_runtime());
    import_react5 = __toESM(require_react());
    init_shallowequal_esm();
    init_invariant_esm();
    init_core();
    init_utils();
    init_disposables();
    init_utils();
    import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
  }
});

// node_modules/react-dnd/dist/esm/decorators/createSourceFactory.js
function _classCallCheck10(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties10(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass10(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties10(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties10(Constructor, staticProps);
  return Constructor;
}
function _defineProperty15(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function createSourceFactory(spec) {
  Object.keys(spec).forEach(function(key) {
    invariant(ALLOWED_SPEC_METHODS.indexOf(key) > -1, 'Expected the drag source specification to only have some of the following keys: %s. Instead received a specification with an unexpected "%s" key. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', ALLOWED_SPEC_METHODS.join(", "), key);
    invariant(typeof spec[key] === "function", "Expected %s in the drag source specification to be a function. Instead received a specification with %s: %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source", key, key, spec[key]);
  });
  REQUIRED_SPEC_METHODS.forEach(function(key) {
    invariant(typeof spec[key] === "function", "Expected %s in the drag source specification to be a function. Instead received a specification with %s: %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source", key, key, spec[key]);
  });
  return function createSource(monitor, ref) {
    return new SourceImpl(spec, monitor, ref);
  };
}
var ALLOWED_SPEC_METHODS, REQUIRED_SPEC_METHODS, SourceImpl;
var init_createSourceFactory = __esm({
  "node_modules/react-dnd/dist/esm/decorators/createSourceFactory.js"() {
    init_invariant_esm();
    init_utils();
    ALLOWED_SPEC_METHODS = ["canDrag", "beginDrag", "isDragging", "endDrag"];
    REQUIRED_SPEC_METHODS = ["beginDrag"];
    SourceImpl = function() {
      function SourceImpl2(spec, monitor, ref) {
        var _this = this;
        _classCallCheck10(this, SourceImpl2);
        _defineProperty15(this, "props", null);
        _defineProperty15(this, "spec", void 0);
        _defineProperty15(this, "monitor", void 0);
        _defineProperty15(this, "ref", void 0);
        _defineProperty15(this, "beginDrag", function() {
          if (!_this.props) {
            return;
          }
          var item = _this.spec.beginDrag(_this.props, _this.monitor, _this.ref.current);
          if (true) {
            invariant(isPlainObject2(item), "beginDrag() must return a plain object that represents the dragged item. Instead received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source", item);
          }
          return item;
        });
        this.spec = spec;
        this.monitor = monitor;
        this.ref = ref;
      }
      _createClass10(SourceImpl2, [{
        key: "receiveProps",
        value: function receiveProps(props) {
          this.props = props;
        }
      }, {
        key: "canDrag",
        value: function canDrag() {
          if (!this.props) {
            return false;
          }
          if (!this.spec.canDrag) {
            return true;
          }
          return this.spec.canDrag(this.props, this.monitor);
        }
      }, {
        key: "isDragging",
        value: function isDragging(globalMonitor, sourceId) {
          if (!this.props) {
            return false;
          }
          if (!this.spec.isDragging) {
            return sourceId === globalMonitor.getSourceId();
          }
          return this.spec.isDragging(this.props, this.monitor);
        }
      }, {
        key: "endDrag",
        value: function endDrag() {
          if (!this.props) {
            return;
          }
          if (!this.spec.endDrag) {
            return;
          }
          this.spec.endDrag(this.props, this.monitor, getDecoratedComponent(this.ref));
        }
      }]);
      return SourceImpl2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/decorators/DragSource.js
function DragSource(type, spec, collect) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  checkDecoratorArguments("DragSource", "type, spec, collect[, options]", type, spec, collect, options);
  var getType = type;
  if (typeof type !== "function") {
    invariant(isValidType(type), 'Expected "type" provided as the first argument to DragSource to be a string, or a function that returns a string given the current props. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', type);
    getType = function getType2() {
      return type;
    };
  }
  invariant(isPlainObject2(spec), 'Expected "spec" provided as the second argument to DragSource to be a plain object. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', spec);
  var createSource = createSourceFactory(spec);
  invariant(typeof collect === "function", 'Expected "collect" provided as the third argument to DragSource to be a function that returns a plain object of props to inject. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', collect);
  invariant(isPlainObject2(options), 'Expected "options" provided as the fourth argument to DragSource to be a plain object when specified. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source', collect);
  return function decorateSource(DecoratedComponent) {
    return decorateHandler({
      containerDisplayName: "DragSource",
      createHandler: createSource,
      registerHandler: registerSource,
      createConnector: function createConnector(backend) {
        return new SourceConnector(backend);
      },
      createMonitor: function createMonitor(manager) {
        return new DragSourceMonitorImpl(manager);
      },
      DecoratedComponent,
      getType,
      collect,
      options
    });
  };
}
var init_DragSource = __esm({
  "node_modules/react-dnd/dist/esm/decorators/DragSource.js"() {
    init_invariant_esm();
    init_internals();
    init_utils();
    init_decorateHandler();
    init_createSourceFactory();
  }
});

// node_modules/react-dnd/dist/esm/decorators/createTargetFactory.js
function _classCallCheck11(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties11(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass11(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties11(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties11(Constructor, staticProps);
  return Constructor;
}
function _defineProperty16(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function createTargetFactory(spec) {
  Object.keys(spec).forEach(function(key) {
    invariant(ALLOWED_SPEC_METHODS2.indexOf(key) > -1, 'Expected the drop target specification to only have some of the following keys: %s. Instead received a specification with an unexpected "%s" key. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', ALLOWED_SPEC_METHODS2.join(", "), key);
    invariant(typeof spec[key] === "function", "Expected %s in the drop target specification to be a function. Instead received a specification with %s: %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target", key, key, spec[key]);
  });
  return function createTarget(monitor, ref) {
    return new TargetImpl(spec, monitor, ref);
  };
}
var ALLOWED_SPEC_METHODS2, TargetImpl;
var init_createTargetFactory = __esm({
  "node_modules/react-dnd/dist/esm/decorators/createTargetFactory.js"() {
    init_invariant_esm();
    init_utils();
    ALLOWED_SPEC_METHODS2 = ["canDrop", "hover", "drop"];
    TargetImpl = function() {
      function TargetImpl2(spec, monitor, ref) {
        _classCallCheck11(this, TargetImpl2);
        _defineProperty16(this, "props", null);
        _defineProperty16(this, "spec", void 0);
        _defineProperty16(this, "monitor", void 0);
        _defineProperty16(this, "ref", void 0);
        this.spec = spec;
        this.monitor = monitor;
        this.ref = ref;
      }
      _createClass11(TargetImpl2, [{
        key: "receiveProps",
        value: function receiveProps(props) {
          this.props = props;
        }
      }, {
        key: "receiveMonitor",
        value: function receiveMonitor(monitor) {
          this.monitor = monitor;
        }
      }, {
        key: "canDrop",
        value: function canDrop() {
          if (!this.spec.canDrop) {
            return true;
          }
          return this.spec.canDrop(this.props, this.monitor);
        }
      }, {
        key: "hover",
        value: function hover() {
          if (!this.spec.hover || !this.props) {
            return;
          }
          this.spec.hover(this.props, this.monitor, getDecoratedComponent(this.ref));
        }
      }, {
        key: "drop",
        value: function drop() {
          if (!this.spec.drop) {
            return void 0;
          }
          var dropResult = this.spec.drop(this.props, this.monitor, this.ref.current);
          if (true) {
            invariant(typeof dropResult === "undefined" || isPlainObject2(dropResult), "drop() must either return undefined, or an object that represents the drop result. Instead received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target", dropResult);
          }
          return dropResult;
        }
      }]);
      return TargetImpl2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/decorators/DropTarget.js
function DropTarget(type, spec, collect) {
  var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
  checkDecoratorArguments("DropTarget", "type, spec, collect[, options]", type, spec, collect, options);
  var getType = type;
  if (typeof type !== "function") {
    invariant(isValidType(type, true), 'Expected "type" provided as the first argument to DropTarget to be a string, an array of strings, or a function that returns either given the current props. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', type);
    getType = function getType2() {
      return type;
    };
  }
  invariant(isPlainObject2(spec), 'Expected "spec" provided as the second argument to DropTarget to be a plain object. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', spec);
  var createTarget = createTargetFactory(spec);
  invariant(typeof collect === "function", 'Expected "collect" provided as the third argument to DropTarget to be a function that returns a plain object of props to inject. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', collect);
  invariant(isPlainObject2(options), 'Expected "options" provided as the fourth argument to DropTarget to be a plain object when specified. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target', collect);
  return function decorateTarget(DecoratedComponent) {
    return decorateHandler({
      containerDisplayName: "DropTarget",
      createHandler: createTarget,
      registerHandler: registerTarget,
      createMonitor: function createMonitor(manager) {
        return new DropTargetMonitorImpl(manager);
      },
      createConnector: function createConnector(backend) {
        return new TargetConnector(backend);
      },
      DecoratedComponent,
      getType,
      collect,
      options
    });
  };
}
var init_DropTarget = __esm({
  "node_modules/react-dnd/dist/esm/decorators/DropTarget.js"() {
    init_invariant_esm();
    init_internals();
    init_utils();
    init_utils();
    init_decorateHandler();
    init_createTargetFactory();
  }
});

// node_modules/react-dnd/dist/esm/decorators/DragLayer.js
function _typeof7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof7 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof7 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof7(obj);
}
function _classCallCheck12(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties12(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass12(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties12(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties12(Constructor, staticProps);
  return Constructor;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o, p) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf2(o, p);
}
function _createSuper2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn2(this, result);
  };
}
function _possibleConstructorReturn2(self2, call) {
  if (call && (_typeof7(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized2(self2);
}
function _assertThisInitialized2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _getPrototypeOf2(o) {
  _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf2(o);
}
function _defineProperty17(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function DragLayer(collect) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  checkDecoratorArguments("DragLayer", "collect[, options]", collect, options);
  invariant(typeof collect === "function", 'Expected "collect" provided as the first argument to DragLayer to be a function that collects props to inject into the component. ', "Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-layer", collect);
  invariant(isPlainObject2(options), 'Expected "options" provided as the second argument to DragLayer to be a plain object when specified. Instead, received %s. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-layer', options);
  return function decorateLayer(DecoratedComponent) {
    var Decorated = DecoratedComponent;
    var _options$arePropsEqua = options.arePropsEqual, arePropsEqual = _options$arePropsEqua === void 0 ? shallowEqual : _options$arePropsEqua;
    var displayName = Decorated.displayName || Decorated.name || "Component";
    var DragLayerContainer = function(_Component) {
      _inherits2(DragLayerContainer2, _Component);
      var _super = _createSuper2(DragLayerContainer2);
      function DragLayerContainer2() {
        var _this;
        _classCallCheck12(this, DragLayerContainer2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty17(_assertThisInitialized2(_this), "manager", void 0);
        _defineProperty17(_assertThisInitialized2(_this), "isCurrentlyMounted", false);
        _defineProperty17(_assertThisInitialized2(_this), "unsubscribeFromOffsetChange", void 0);
        _defineProperty17(_assertThisInitialized2(_this), "unsubscribeFromStateChange", void 0);
        _defineProperty17(_assertThisInitialized2(_this), "ref", (0, import_react6.createRef)());
        _defineProperty17(_assertThisInitialized2(_this), "handleChange", function() {
          if (!_this.isCurrentlyMounted) {
            return;
          }
          var nextState = _this.getCurrentState();
          if (!shallowEqual(nextState, _this.state)) {
            _this.setState(nextState);
          }
        });
        return _this;
      }
      _createClass12(DragLayerContainer2, [{
        key: "getDecoratedComponentInstance",
        value: function getDecoratedComponentInstance() {
          invariant(this.ref.current, "In order to access an instance of the decorated component, it must either be a class component or use React.forwardRef()");
          return this.ref.current;
        }
      }, {
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps, nextState) {
          return !arePropsEqual(nextProps, this.props) || !shallowEqual(nextState, this.state);
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          this.isCurrentlyMounted = true;
          this.handleChange();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.isCurrentlyMounted = false;
          if (this.unsubscribeFromOffsetChange) {
            this.unsubscribeFromOffsetChange();
            this.unsubscribeFromOffsetChange = void 0;
          }
          if (this.unsubscribeFromStateChange) {
            this.unsubscribeFromStateChange();
            this.unsubscribeFromStateChange = void 0;
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          return (0, import_jsx_runtime3.jsx)(DndContext.Consumer, {
            children: function children(_ref) {
              var dragDropManager = _ref.dragDropManager;
              if (dragDropManager === void 0) {
                return null;
              }
              _this2.receiveDragDropManager(dragDropManager);
              if (!_this2.isCurrentlyMounted) {
                return null;
              }
              return (0, import_jsx_runtime3.jsx)(Decorated, Object.assign({}, _this2.props, _this2.state, {
                ref: isRefable(Decorated) ? _this2.ref : null
              }), void 0);
            }
          }, void 0);
        }
      }, {
        key: "receiveDragDropManager",
        value: function receiveDragDropManager(dragDropManager) {
          if (this.manager !== void 0) {
            return;
          }
          this.manager = dragDropManager;
          invariant(_typeof7(dragDropManager) === "object", "Could not find the drag and drop manager in the context of %s. Make sure to render a DndProvider component in your top-level component. Read more: http://react-dnd.github.io/react-dnd/docs/troubleshooting#could-not-find-the-drag-and-drop-manager-in-the-context", displayName, displayName);
          var monitor = this.manager.getMonitor();
          this.unsubscribeFromOffsetChange = monitor.subscribeToOffsetChange(this.handleChange);
          this.unsubscribeFromStateChange = monitor.subscribeToStateChange(this.handleChange);
        }
      }, {
        key: "getCurrentState",
        value: function getCurrentState() {
          if (!this.manager) {
            return {};
          }
          var monitor = this.manager.getMonitor();
          return collect(monitor, this.props);
        }
      }]);
      return DragLayerContainer2;
    }(import_react6.Component);
    _defineProperty17(DragLayerContainer, "displayName", "DragLayer(".concat(displayName, ")"));
    _defineProperty17(DragLayerContainer, "DecoratedComponent", DecoratedComponent);
    return (0, import_hoist_non_react_statics2.default)(DragLayerContainer, DecoratedComponent);
  };
}
var import_jsx_runtime3, import_react6, import_hoist_non_react_statics2;
var init_DragLayer = __esm({
  "node_modules/react-dnd/dist/esm/decorators/DragLayer.js"() {
    import_jsx_runtime3 = __toESM(require_jsx_runtime());
    import_react6 = __toESM(require_react());
    init_shallowequal_esm();
    init_invariant_esm();
    import_hoist_non_react_statics2 = __toESM(require_hoist_non_react_statics_cjs());
    init_core();
    init_utils();
  }
});

// node_modules/react-dnd/dist/esm/decorators/types.js
var init_types4 = __esm({
  "node_modules/react-dnd/dist/esm/decorators/types.js"() {
  }
});

// node_modules/react-dnd/dist/esm/decorators/index.js
var init_decorators = __esm({
  "node_modules/react-dnd/dist/esm/decorators/index.js"() {
    init_DragSource();
    init_DropTarget();
    init_DragLayer();
    init_types4();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useIsomorphicLayoutEffect.js
var import_react7, useIsomorphicLayoutEffect;
var init_useIsomorphicLayoutEffect = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useIsomorphicLayoutEffect.js"() {
    import_react7 = __toESM(require_react());
    useIsomorphicLayoutEffect = typeof window !== "undefined" ? import_react7.useLayoutEffect : import_react7.useEffect;
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/DragSourceImpl.js
function _typeof8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof8 = function _typeof9(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof8 = function _typeof9(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof8(obj);
}
function _classCallCheck13(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties13(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass13(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties13(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties13(Constructor, staticProps);
  return Constructor;
}
function _defineProperty18(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DragSourceImpl;
var init_DragSourceImpl = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/DragSourceImpl.js"() {
    DragSourceImpl = function() {
      function DragSourceImpl2(spec, monitor, connector) {
        _classCallCheck13(this, DragSourceImpl2);
        _defineProperty18(this, "spec", void 0);
        _defineProperty18(this, "monitor", void 0);
        _defineProperty18(this, "connector", void 0);
        this.spec = spec;
        this.monitor = monitor;
        this.connector = connector;
      }
      _createClass13(DragSourceImpl2, [{
        key: "beginDrag",
        value: function beginDrag() {
          var _result;
          var spec = this.spec;
          var monitor = this.monitor;
          var result = null;
          if (_typeof8(spec.item) === "object") {
            result = spec.item;
          } else if (typeof spec.item === "function") {
            result = spec.item(monitor);
          } else {
            result = {};
          }
          return (_result = result) !== null && _result !== void 0 ? _result : null;
        }
      }, {
        key: "canDrag",
        value: function canDrag() {
          var spec = this.spec;
          var monitor = this.monitor;
          if (typeof spec.canDrag === "boolean") {
            return spec.canDrag;
          } else if (typeof spec.canDrag === "function") {
            return spec.canDrag(monitor);
          } else {
            return true;
          }
        }
      }, {
        key: "isDragging",
        value: function isDragging(globalMonitor, target) {
          var spec = this.spec;
          var monitor = this.monitor;
          var isDragging2 = spec.isDragging;
          return isDragging2 ? isDragging2(monitor) : target === globalMonitor.getSourceId();
        }
      }, {
        key: "endDrag",
        value: function endDrag() {
          var spec = this.spec;
          var monitor = this.monitor;
          var connector = this.connector;
          var end = spec.end;
          if (end) {
            end(monitor.getItem(), monitor);
          }
          connector.reconnect();
        }
      }]);
      return DragSourceImpl2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/useDragSource.js
function useDragSource(spec, monitor, connector) {
  var handler = (0, import_react8.useMemo)(function() {
    return new DragSourceImpl(spec, monitor, connector);
  }, [monitor, connector]);
  (0, import_react8.useEffect)(function() {
    handler.spec = spec;
  }, [spec]);
  return handler;
}
var import_react8;
var init_useDragSource = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/useDragSource.js"() {
    import_react8 = __toESM(require_react());
    init_DragSourceImpl();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDragDropManager.js
function useDragDropManager() {
  var _useContext = (0, import_react9.useContext)(DndContext), dragDropManager = _useContext.dragDropManager;
  invariant(dragDropManager != null, "Expected drag drop context");
  return dragDropManager;
}
var import_react9;
var init_useDragDropManager = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDragDropManager.js"() {
    import_react9 = __toESM(require_react());
    init_invariant_esm();
    init_core();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/useDragType.js
function useDragType(spec) {
  return (0, import_react10.useMemo)(function() {
    var result = spec.type;
    invariant(result != null, "spec.type must be defined");
    return result;
  }, [spec]);
}
var import_react10;
var init_useDragType = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/useDragType.js"() {
    init_invariant_esm();
    import_react10 = __toESM(require_react());
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/useRegisteredDragSource.js
function _slicedToArray4(arr, i) {
  return _arrayWithHoles4(arr) || _iterableToArrayLimit4(arr, i) || _unsupportedIterableToArray4(arr, i) || _nonIterableRest4();
}
function _nonIterableRest4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray4(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray4(o, minLen);
}
function _arrayLikeToArray4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit4(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useRegisteredDragSource(spec, monitor, connector) {
  var manager = useDragDropManager();
  var handler = useDragSource(spec, monitor, connector);
  var itemType = useDragType(spec);
  useIsomorphicLayoutEffect(function registerDragSource() {
    if (itemType != null) {
      var _registerSource = registerSource(itemType, handler, manager), _registerSource2 = _slicedToArray4(_registerSource, 2), handlerId = _registerSource2[0], unregister = _registerSource2[1];
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }
  }, [manager, monitor, connector, handler, itemType]);
}
var init_useRegisteredDragSource = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/useRegisteredDragSource.js"() {
    init_internals();
    init_useIsomorphicLayoutEffect();
    init_useDragSource();
    init_useDragDropManager();
    init_useDragType();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useOptionalFactory.js
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray5(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray5(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray5(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray5(arr);
}
function _arrayLikeToArray5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function useOptionalFactory(arg, deps) {
  var memoDeps = _toConsumableArray(deps || []);
  if (deps == null && typeof arg !== "function") {
    memoDeps.push(arg);
  }
  return (0, import_react11.useMemo)(function() {
    return typeof arg === "function" ? arg() : arg;
  }, memoDeps);
}
var import_react11;
var init_useOptionalFactory = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useOptionalFactory.js"() {
    import_react11 = __toESM(require_react());
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/useDragSourceMonitor.js
function useDragSourceMonitor() {
  var manager = useDragDropManager();
  return (0, import_react12.useMemo)(function() {
    return new DragSourceMonitorImpl(manager);
  }, [manager]);
}
var import_react12;
var init_useDragSourceMonitor = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/useDragSourceMonitor.js"() {
    import_react12 = __toESM(require_react());
    init_internals();
    init_useDragDropManager();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/useDragSourceConnector.js
function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
  var manager = useDragDropManager();
  var connector = (0, import_react13.useMemo)(function() {
    return new SourceConnector(manager.getBackend());
  }, [manager]);
  useIsomorphicLayoutEffect(function() {
    connector.dragSourceOptions = dragSourceOptions || null;
    connector.reconnect();
    return function() {
      return connector.disconnectDragSource();
    };
  }, [connector, dragSourceOptions]);
  useIsomorphicLayoutEffect(function() {
    connector.dragPreviewOptions = dragPreviewOptions || null;
    connector.reconnect();
    return function() {
      return connector.disconnectDragPreview();
    };
  }, [connector, dragPreviewOptions]);
  return connector;
}
var import_react13;
var init_useDragSourceConnector = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/useDragSourceConnector.js"() {
    import_react13 = __toESM(require_react());
    init_internals();
    init_useDragDropManager();
    init_useIsomorphicLayoutEffect();
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal2(a, b) {
      if (a === b)
        return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor)
          return false;
        var length, i, keys;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length)
            return false;
          for (i = length; i-- !== 0; )
            if (!equal2(a[i], b[i]))
              return false;
          return true;
        }
        if (a.constructor === RegExp)
          return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf)
          return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString)
          return a.toString() === b.toString();
        keys = Object.keys(a);
        length = keys.length;
        if (length !== Object.keys(b).length)
          return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
            return false;
        for (i = length; i-- !== 0; ) {
          var key = keys[i];
          if (!equal2(a[key], b[key]))
            return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/react-dnd/dist/esm/hooks/useCollector.js
function _slicedToArray5(arr, i) {
  return _arrayWithHoles5(arr) || _iterableToArrayLimit5(arr, i) || _unsupportedIterableToArray6(arr, i) || _nonIterableRest5();
}
function _nonIterableRest5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray6(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray6(o, minLen);
}
function _arrayLikeToArray6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit5(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles5(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useCollector(monitor, collect, onUpdate) {
  var _useState = (0, import_react14.useState)(function() {
    return collect(monitor);
  }), _useState2 = _slicedToArray5(_useState, 2), collected = _useState2[0], setCollected = _useState2[1];
  var updateCollected = (0, import_react14.useCallback)(function() {
    var nextValue = collect(monitor);
    if (!(0, import_fast_deep_equal.default)(collected, nextValue)) {
      setCollected(nextValue);
      if (onUpdate) {
        onUpdate();
      }
    }
  }, [collected, monitor, onUpdate]);
  useIsomorphicLayoutEffect(updateCollected);
  return [collected, updateCollected];
}
var import_fast_deep_equal, import_react14;
var init_useCollector = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useCollector.js"() {
    import_fast_deep_equal = __toESM(require_fast_deep_equal());
    import_react14 = __toESM(require_react());
    init_useIsomorphicLayoutEffect();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useMonitorOutput.js
function _slicedToArray6(arr, i) {
  return _arrayWithHoles6(arr) || _iterableToArrayLimit6(arr, i) || _unsupportedIterableToArray7(arr, i) || _nonIterableRest6();
}
function _nonIterableRest6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray7(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray7(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray7(o, minLen);
}
function _arrayLikeToArray7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit6(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles6(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useMonitorOutput(monitor, collect, onCollect) {
  var _useCollector = useCollector(monitor, collect, onCollect), _useCollector2 = _slicedToArray6(_useCollector, 2), collected = _useCollector2[0], updateCollected = _useCollector2[1];
  useIsomorphicLayoutEffect(function subscribeToMonitorStateChange() {
    var handlerId = monitor.getHandlerId();
    if (handlerId == null) {
      return;
    }
    return monitor.subscribeToStateChange(updateCollected, {
      handlerIds: [handlerId]
    });
  }, [monitor, updateCollected]);
  return collected;
}
var init_useMonitorOutput = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useMonitorOutput.js"() {
    init_useIsomorphicLayoutEffect();
    init_useCollector();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useCollectedProps.js
function useCollectedProps(collector, monitor, connector) {
  return useMonitorOutput(monitor, collector || function() {
    return {};
  }, function() {
    return connector.reconnect();
  });
}
var init_useCollectedProps = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useCollectedProps.js"() {
    init_useMonitorOutput();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/connectors.js
function useConnectDragSource(connector) {
  return (0, import_react15.useMemo)(function() {
    return connector.hooks.dragSource();
  }, [connector]);
}
function useConnectDragPreview(connector) {
  return (0, import_react15.useMemo)(function() {
    return connector.hooks.dragPreview();
  }, [connector]);
}
var import_react15;
var init_connectors2 = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/connectors.js"() {
    import_react15 = __toESM(require_react());
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/useDrag.js
function useDrag(specArg, deps) {
  var spec = useOptionalFactory(specArg, deps);
  invariant(!spec.begin, "useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)");
  var monitor = useDragSourceMonitor();
  var connector = useDragSourceConnector(spec.options, spec.previewOptions);
  useRegisteredDragSource(spec, monitor, connector);
  return [useCollectedProps(spec.collect, monitor, connector), useConnectDragSource(connector), useConnectDragPreview(connector)];
}
var init_useDrag = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/useDrag.js"() {
    init_useRegisteredDragSource();
    init_useOptionalFactory();
    init_useDragSourceMonitor();
    init_useDragSourceConnector();
    init_useCollectedProps();
    init_connectors2();
    init_invariant_esm();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrag/index.js
var init_useDrag2 = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrag/index.js"() {
    init_useDrag();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/useAccept.js
function useAccept(spec) {
  var accept = spec.accept;
  return (0, import_react16.useMemo)(function() {
    invariant(spec.accept != null, "accept must be defined");
    return Array.isArray(accept) ? accept : [accept];
  }, [accept]);
}
var import_react16;
var init_useAccept = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/useAccept.js"() {
    init_invariant_esm();
    import_react16 = __toESM(require_react());
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/DropTargetImpl.js
function _classCallCheck14(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties14(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass14(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties14(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties14(Constructor, staticProps);
  return Constructor;
}
function _defineProperty19(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DropTargetImpl;
var init_DropTargetImpl = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/DropTargetImpl.js"() {
    DropTargetImpl = function() {
      function DropTargetImpl2(spec, monitor) {
        _classCallCheck14(this, DropTargetImpl2);
        _defineProperty19(this, "spec", void 0);
        _defineProperty19(this, "monitor", void 0);
        this.spec = spec;
        this.monitor = monitor;
      }
      _createClass14(DropTargetImpl2, [{
        key: "canDrop",
        value: function canDrop() {
          var spec = this.spec;
          var monitor = this.monitor;
          return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
        }
      }, {
        key: "hover",
        value: function hover() {
          var spec = this.spec;
          var monitor = this.monitor;
          if (spec.hover) {
            spec.hover(monitor.getItem(), monitor);
          }
        }
      }, {
        key: "drop",
        value: function drop() {
          var spec = this.spec;
          var monitor = this.monitor;
          if (spec.drop) {
            return spec.drop(monitor.getItem(), monitor);
          }
        }
      }]);
      return DropTargetImpl2;
    }();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTarget.js
function useDropTarget(spec, monitor) {
  var dropTarget = (0, import_react17.useMemo)(function() {
    return new DropTargetImpl(spec, monitor);
  }, [monitor]);
  (0, import_react17.useEffect)(function() {
    dropTarget.spec = spec;
  }, [spec]);
  return dropTarget;
}
var import_react17;
var init_useDropTarget = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTarget.js"() {
    import_react17 = __toESM(require_react());
    init_DropTargetImpl();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/useRegisteredDropTarget.js
function _slicedToArray7(arr, i) {
  return _arrayWithHoles7(arr) || _iterableToArrayLimit7(arr, i) || _unsupportedIterableToArray8(arr, i) || _nonIterableRest7();
}
function _nonIterableRest7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray8(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray8(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray8(o, minLen);
}
function _arrayLikeToArray8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit7(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles7(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useRegisteredDropTarget(spec, monitor, connector) {
  var manager = useDragDropManager();
  var dropTarget = useDropTarget(spec, monitor);
  var accept = useAccept(spec);
  useIsomorphicLayoutEffect(function registerDropTarget() {
    var _registerTarget = registerTarget(accept, dropTarget, manager), _registerTarget2 = _slicedToArray7(_registerTarget, 2), handlerId = _registerTarget2[0], unregister = _registerTarget2[1];
    monitor.receiveHandlerId(handlerId);
    connector.receiveHandlerId(handlerId);
    return unregister;
  }, [manager, monitor, dropTarget, connector, accept.map(function(a) {
    return a.toString();
  }).join("|")]);
}
var init_useRegisteredDropTarget = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/useRegisteredDropTarget.js"() {
    init_internals();
    init_useDragDropManager();
    init_useIsomorphicLayoutEffect();
    init_useAccept();
    init_useDropTarget();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTargetMonitor.js
function useDropTargetMonitor() {
  var manager = useDragDropManager();
  return (0, import_react18.useMemo)(function() {
    return new DropTargetMonitorImpl(manager);
  }, [manager]);
}
var import_react18;
var init_useDropTargetMonitor = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTargetMonitor.js"() {
    import_react18 = __toESM(require_react());
    init_internals();
    init_useDragDropManager();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTargetConnector.js
function useDropTargetConnector(options) {
  var manager = useDragDropManager();
  var connector = (0, import_react19.useMemo)(function() {
    return new TargetConnector(manager.getBackend());
  }, [manager]);
  useIsomorphicLayoutEffect(function() {
    connector.dropTargetOptions = options || null;
    connector.reconnect();
    return function() {
      return connector.disconnectDropTarget();
    };
  }, [options]);
  return connector;
}
var import_react19;
var init_useDropTargetConnector = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/useDropTargetConnector.js"() {
    import_react19 = __toESM(require_react());
    init_internals();
    init_useDragDropManager();
    init_useIsomorphicLayoutEffect();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/connectors.js
function useConnectDropTarget(connector) {
  return (0, import_react20.useMemo)(function() {
    return connector.hooks.dropTarget();
  }, [connector]);
}
var import_react20;
var init_connectors3 = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/connectors.js"() {
    import_react20 = __toESM(require_react());
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/useDrop.js
function useDrop(specArg, deps) {
  var spec = useOptionalFactory(specArg, deps);
  var monitor = useDropTargetMonitor();
  var connector = useDropTargetConnector(spec.options);
  useRegisteredDropTarget(spec, monitor, connector);
  return [useCollectedProps(spec.collect, monitor, connector), useConnectDropTarget(connector)];
}
var init_useDrop = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/useDrop.js"() {
    init_useRegisteredDropTarget();
    init_useOptionalFactory();
    init_useDropTargetMonitor();
    init_useDropTargetConnector();
    init_useCollectedProps();
    init_connectors3();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDrop/index.js
var init_useDrop2 = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDrop/index.js"() {
    init_useDrop();
  }
});

// node_modules/react-dnd/dist/esm/hooks/useDragLayer.js
function _slicedToArray8(arr, i) {
  return _arrayWithHoles8(arr) || _iterableToArrayLimit8(arr, i) || _unsupportedIterableToArray9(arr, i) || _nonIterableRest8();
}
function _nonIterableRest8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray9(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray9(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray9(o, minLen);
}
function _arrayLikeToArray9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit8(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles8(arr) {
  if (Array.isArray(arr))
    return arr;
}
function useDragLayer(collect) {
  var dragDropManager = useDragDropManager();
  var monitor = dragDropManager.getMonitor();
  var _useCollector = useCollector(monitor, collect), _useCollector2 = _slicedToArray8(_useCollector, 2), collected = _useCollector2[0], updateCollected = _useCollector2[1];
  (0, import_react21.useEffect)(function() {
    return monitor.subscribeToOffsetChange(updateCollected);
  });
  (0, import_react21.useEffect)(function() {
    return monitor.subscribeToStateChange(updateCollected);
  });
  return collected;
}
var import_react21;
var init_useDragLayer = __esm({
  "node_modules/react-dnd/dist/esm/hooks/useDragLayer.js"() {
    import_react21 = __toESM(require_react());
    init_useDragDropManager();
    init_useCollector();
  }
});

// node_modules/react-dnd/dist/esm/hooks/types.js
var init_types5 = __esm({
  "node_modules/react-dnd/dist/esm/hooks/types.js"() {
  }
});

// node_modules/react-dnd/dist/esm/hooks/index.js
var init_hooks = __esm({
  "node_modules/react-dnd/dist/esm/hooks/index.js"() {
    init_useDrag2();
    init_useDrop2();
    init_useDragLayer();
    init_useDragDropManager();
    init_types5();
  }
});

// node_modules/react-dnd/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  DndContext: () => DndContext,
  DndProvider: () => DndProvider,
  DragLayer: () => DragLayer,
  DragPreviewImage: () => DragPreviewImage,
  DragSource: () => DragSource,
  DropTarget: () => DropTarget,
  useDrag: () => useDrag,
  useDragDropManager: () => useDragDropManager,
  useDragLayer: () => useDragLayer,
  useDrop: () => useDrop
});
var init_esm3 = __esm({
  "node_modules/react-dnd/dist/esm/index.js"() {
    init_types();
    init_core();
    init_decorators();
    init_hooks();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/utils/js_utils.js
function memoize(fn) {
  var result = null;
  var memoized = function memoized2() {
    if (result == null) {
      result = fn();
    }
    return result;
  };
  return memoized;
}
function without2(items2, item) {
  return items2.filter(function(i) {
    return i !== item;
  });
}
function union(itemsA, itemsB) {
  var set = /* @__PURE__ */ new Set();
  var insertItem = function insertItem2(item) {
    return set.add(item);
  };
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  var result = [];
  set.forEach(function(key) {
    return result.push(key);
  });
  return result;
}
var init_js_utils2 = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/utils/js_utils.js"() {
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/EnterLeaveCounter.js
function _classCallCheck15(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties15(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass15(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties15(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties15(Constructor, staticProps);
  return Constructor;
}
function _defineProperty20(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EnterLeaveCounter;
var init_EnterLeaveCounter = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/EnterLeaveCounter.js"() {
    init_js_utils2();
    EnterLeaveCounter = function() {
      function EnterLeaveCounter2(isNodeInDocument) {
        _classCallCheck15(this, EnterLeaveCounter2);
        _defineProperty20(this, "entered", []);
        _defineProperty20(this, "isNodeInDocument", void 0);
        this.isNodeInDocument = isNodeInDocument;
      }
      _createClass15(EnterLeaveCounter2, [{
        key: "enter",
        value: function enter(enteringNode) {
          var _this = this;
          var previousLength = this.entered.length;
          var isNodeEntered = function isNodeEntered2(node) {
            return _this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));
          };
          this.entered = union(this.entered.filter(isNodeEntered), [enteringNode]);
          return previousLength === 0 && this.entered.length > 0;
        }
      }, {
        key: "leave",
        value: function leave(leavingNode) {
          var previousLength = this.entered.length;
          this.entered = without2(this.entered.filter(this.isNodeInDocument), leavingNode);
          return previousLength > 0 && this.entered.length === 0;
        }
      }, {
        key: "reset",
        value: function reset() {
          this.entered = [];
        }
      }]);
      return EnterLeaveCounter2;
    }();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/BrowserDetector.js
var isFirefox, isSafari;
var init_BrowserDetector = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/BrowserDetector.js"() {
    init_js_utils2();
    isFirefox = memoize(function() {
      return /firefox/i.test(navigator.userAgent);
    });
    isSafari = memoize(function() {
      return Boolean(window.safari);
    });
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/MonotonicInterpolant.js
function _classCallCheck16(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties16(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass16(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties16(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties16(Constructor, staticProps);
  return Constructor;
}
function _defineProperty21(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonotonicInterpolant;
var init_MonotonicInterpolant = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/MonotonicInterpolant.js"() {
    MonotonicInterpolant = function() {
      function MonotonicInterpolant2(xs, ys) {
        _classCallCheck16(this, MonotonicInterpolant2);
        _defineProperty21(this, "xs", void 0);
        _defineProperty21(this, "ys", void 0);
        _defineProperty21(this, "c1s", void 0);
        _defineProperty21(this, "c2s", void 0);
        _defineProperty21(this, "c3s", void 0);
        var length = xs.length;
        var indexes = [];
        for (var i = 0; i < length; i++) {
          indexes.push(i);
        }
        indexes.sort(function(a, b) {
          return xs[a] < xs[b] ? -1 : 1;
        });
        var dys = [];
        var dxs = [];
        var ms = [];
        var dx;
        var dy;
        for (var _i = 0; _i < length - 1; _i++) {
          dx = xs[_i + 1] - xs[_i];
          dy = ys[_i + 1] - ys[_i];
          dxs.push(dx);
          dys.push(dy);
          ms.push(dy / dx);
        }
        var c1s = [ms[0]];
        for (var _i2 = 0; _i2 < dxs.length - 1; _i2++) {
          var m2 = ms[_i2];
          var mNext = ms[_i2 + 1];
          if (m2 * mNext <= 0) {
            c1s.push(0);
          } else {
            dx = dxs[_i2];
            var dxNext = dxs[_i2 + 1];
            var common = dx + dxNext;
            c1s.push(3 * common / ((common + dxNext) / m2 + (common + dx) / mNext));
          }
        }
        c1s.push(ms[ms.length - 1]);
        var c2s = [];
        var c3s = [];
        var m;
        for (var _i3 = 0; _i3 < c1s.length - 1; _i3++) {
          m = ms[_i3];
          var c1 = c1s[_i3];
          var invDx = 1 / dxs[_i3];
          var _common = c1 + c1s[_i3 + 1] - m - m;
          c2s.push((m - c1 - _common) * invDx);
          c3s.push(_common * invDx * invDx);
        }
        this.xs = xs;
        this.ys = ys;
        this.c1s = c1s;
        this.c2s = c2s;
        this.c3s = c3s;
      }
      _createClass16(MonotonicInterpolant2, [{
        key: "interpolate",
        value: function interpolate(x) {
          var xs = this.xs, ys = this.ys, c1s = this.c1s, c2s = this.c2s, c3s = this.c3s;
          var i = xs.length - 1;
          if (x === xs[i]) {
            return ys[i];
          }
          var low = 0;
          var high = c3s.length - 1;
          var mid;
          while (low <= high) {
            mid = Math.floor(0.5 * (low + high));
            var xHere = xs[mid];
            if (xHere < x) {
              low = mid + 1;
            } else if (xHere > x) {
              high = mid - 1;
            } else {
              return ys[mid];
            }
          }
          i = Math.max(0, high);
          var diff = x - xs[i];
          var diffSq = diff * diff;
          return ys[i] + c1s[i] * diff + c2s[i] * diffSq + c3s[i] * diff * diffSq;
        }
      }]);
      return MonotonicInterpolant2;
    }();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/OffsetUtils.js
function getNodeClientOffset(node) {
  var el = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
  if (!el) {
    return null;
  }
  var _el$getBoundingClient = el.getBoundingClientRect(), top = _el$getBoundingClient.top, left = _el$getBoundingClient.left;
  return {
    x: left,
    y: top
  };
}
function getEventClientOffset(e) {
  return {
    x: e.clientX,
    y: e.clientY
  };
}
function isImageNode(node) {
  var _document$documentEle;
  return node.nodeName === "IMG" && (isFirefox() || !((_document$documentEle = document.documentElement) !== null && _document$documentEle !== void 0 && _document$documentEle.contains(node)));
}
function getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight) {
  var dragPreviewWidth = isImage ? dragPreview.width : sourceWidth;
  var dragPreviewHeight = isImage ? dragPreview.height : sourceHeight;
  if (isSafari() && isImage) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  }
  return {
    dragPreviewWidth,
    dragPreviewHeight
  };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
  var isImage = isImageNode(dragPreview);
  var dragPreviewNode = isImage ? sourceNode : dragPreview;
  var dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
  var offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };
  var sourceWidth = sourceNode.offsetWidth, sourceHeight = sourceNode.offsetHeight;
  var anchorX = anchorPoint.anchorX, anchorY = anchorPoint.anchorY;
  var _getDragPreviewSize = getDragPreviewSize(isImage, dragPreview, sourceWidth, sourceHeight), dragPreviewWidth = _getDragPreviewSize.dragPreviewWidth, dragPreviewHeight = _getDragPreviewSize.dragPreviewHeight;
  var calculateYOffset = function calculateYOffset2() {
    var interpolantY = new MonotonicInterpolant([0, 0.5, 1], [
      // Dock to the top
      offsetFromDragPreview.y,
      // Align at the center
      offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
      // Dock to the bottom
      offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
    ]);
    var y = interpolantY.interpolate(anchorY);
    if (isSafari() && isImage) {
      y += (window.devicePixelRatio - 1) * dragPreviewHeight;
    }
    return y;
  };
  var calculateXOffset = function calculateXOffset2() {
    var interpolantX = new MonotonicInterpolant([0, 0.5, 1], [
      // Dock to the left
      offsetFromDragPreview.x,
      // Align at the center
      offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
      // Dock to the right
      offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
    ]);
    return interpolantX.interpolate(anchorX);
  };
  var offsetX = offsetPoint.offsetX, offsetY = offsetPoint.offsetY;
  var isManualOffsetX = offsetX === 0 || offsetX;
  var isManualOffsetY = offsetY === 0 || offsetY;
  return {
    x: isManualOffsetX ? offsetX : calculateXOffset(),
    y: isManualOffsetY ? offsetY : calculateYOffset()
  };
}
var ELEMENT_NODE;
var init_OffsetUtils = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/OffsetUtils.js"() {
    init_BrowserDetector();
    init_MonotonicInterpolant();
    ELEMENT_NODE = 1;
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/NativeTypes.js
var NativeTypes_exports = {};
__export(NativeTypes_exports, {
  FILE: () => FILE,
  HTML: () => HTML,
  TEXT: () => TEXT,
  URL: () => URL
});
var FILE, URL, TEXT, HTML;
var init_NativeTypes = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/NativeTypes.js"() {
    FILE = "__NATIVE_FILE__";
    URL = "__NATIVE_URL__";
    TEXT = "__NATIVE_TEXT__";
    HTML = "__NATIVE_HTML__";
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/getDataFromDataTransfer.js
function getDataFromDataTransfer(dataTransfer5, typesToTry, defaultValue) {
  var result = typesToTry.reduce(function(resultSoFar, typeToTry) {
    return resultSoFar || dataTransfer5.getData(typeToTry);
  }, "");
  return result != null ? result : defaultValue;
}
var init_getDataFromDataTransfer = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/getDataFromDataTransfer.js"() {
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/nativeTypesConfig.js
function _defineProperty22(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var _nativeTypesConfig, nativeTypesConfig;
var init_nativeTypesConfig = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/nativeTypesConfig.js"() {
    init_NativeTypes();
    init_getDataFromDataTransfer();
    nativeTypesConfig = (_nativeTypesConfig = {}, _defineProperty22(_nativeTypesConfig, FILE, {
      exposeProperties: {
        files: function files(dataTransfer5) {
          return Array.prototype.slice.call(dataTransfer5.files);
        },
        items: function items(dataTransfer5) {
          return dataTransfer5.items;
        },
        dataTransfer: function dataTransfer(_dataTransfer) {
          return _dataTransfer;
        }
      },
      matchesTypes: ["Files"]
    }), _defineProperty22(_nativeTypesConfig, HTML, {
      exposeProperties: {
        html: function html(dataTransfer5, matchesTypes) {
          return getDataFromDataTransfer(dataTransfer5, matchesTypes, "");
        },
        dataTransfer: function dataTransfer2(_dataTransfer2) {
          return _dataTransfer2;
        }
      },
      matchesTypes: ["Html", "text/html"]
    }), _defineProperty22(_nativeTypesConfig, URL, {
      exposeProperties: {
        urls: function urls(dataTransfer5, matchesTypes) {
          return getDataFromDataTransfer(dataTransfer5, matchesTypes, "").split("\n");
        },
        dataTransfer: function dataTransfer3(_dataTransfer3) {
          return _dataTransfer3;
        }
      },
      matchesTypes: ["Url", "text/uri-list"]
    }), _defineProperty22(_nativeTypesConfig, TEXT, {
      exposeProperties: {
        text: function text(dataTransfer5, matchesTypes) {
          return getDataFromDataTransfer(dataTransfer5, matchesTypes, "");
        },
        dataTransfer: function dataTransfer4(_dataTransfer4) {
          return _dataTransfer4;
        }
      },
      matchesTypes: ["Text", "text/plain"]
    }), _nativeTypesConfig);
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/NativeDragSource.js
function _classCallCheck17(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties17(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass17(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties17(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties17(Constructor, staticProps);
  return Constructor;
}
function _defineProperty23(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var NativeDragSource;
var init_NativeDragSource = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/NativeDragSource.js"() {
    NativeDragSource = function() {
      function NativeDragSource2(config) {
        _classCallCheck17(this, NativeDragSource2);
        _defineProperty23(this, "item", void 0);
        _defineProperty23(this, "config", void 0);
        this.config = config;
        this.item = {};
        this.initializeExposedProperties();
      }
      _createClass17(NativeDragSource2, [{
        key: "initializeExposedProperties",
        value: function initializeExposedProperties() {
          var _this = this;
          Object.keys(this.config.exposeProperties).forEach(function(property) {
            Object.defineProperty(_this.item, property, {
              configurable: true,
              enumerable: true,
              get: function get2() {
                console.warn(`Browser doesn't allow reading "`.concat(property, '" until the drop event.'));
                return null;
              }
            });
          });
        }
      }, {
        key: "loadDataTransfer",
        value: function loadDataTransfer(dataTransfer5) {
          var _this2 = this;
          if (dataTransfer5) {
            var newProperties = {};
            Object.keys(this.config.exposeProperties).forEach(function(property) {
              newProperties[property] = {
                value: _this2.config.exposeProperties[property](dataTransfer5, _this2.config.matchesTypes),
                configurable: true,
                enumerable: true
              };
            });
            Object.defineProperties(this.item, newProperties);
          }
        }
      }, {
        key: "canDrag",
        value: function canDrag() {
          return true;
        }
      }, {
        key: "beginDrag",
        value: function beginDrag() {
          return this.item;
        }
      }, {
        key: "isDragging",
        value: function isDragging(monitor, handle) {
          return handle === monitor.getSourceId();
        }
      }, {
        key: "endDrag",
        value: function endDrag() {
        }
      }]);
      return NativeDragSource2;
    }();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/index.js
function createNativeDragSource(type, dataTransfer5) {
  var result = new NativeDragSource(nativeTypesConfig[type]);
  result.loadDataTransfer(dataTransfer5);
  return result;
}
function matchNativeItemType(dataTransfer5) {
  if (!dataTransfer5) {
    return null;
  }
  var dataTransferTypes = Array.prototype.slice.call(dataTransfer5.types || []);
  return Object.keys(nativeTypesConfig).filter(function(nativeItemType) {
    var matchesTypes = nativeTypesConfig[nativeItemType].matchesTypes;
    return matchesTypes.some(function(t) {
      return dataTransferTypes.indexOf(t) > -1;
    });
  })[0] || null;
}
var init_NativeDragSources = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/NativeDragSources/index.js"() {
    init_nativeTypesConfig();
    init_NativeDragSource();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/OptionsReader.js
function _classCallCheck18(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties18(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass18(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties18(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties18(Constructor, staticProps);
  return Constructor;
}
function _defineProperty24(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var OptionsReader;
var init_OptionsReader = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/OptionsReader.js"() {
    OptionsReader = function() {
      function OptionsReader2(globalContext, options) {
        _classCallCheck18(this, OptionsReader2);
        _defineProperty24(this, "ownerDocument", null);
        _defineProperty24(this, "globalContext", void 0);
        _defineProperty24(this, "optionsArgs", void 0);
        this.globalContext = globalContext;
        this.optionsArgs = options;
      }
      _createClass18(OptionsReader2, [{
        key: "window",
        get: function get2() {
          if (this.globalContext) {
            return this.globalContext;
          } else if (typeof window !== "undefined") {
            return window;
          }
          return void 0;
        }
      }, {
        key: "document",
        get: function get2() {
          var _this$globalContext;
          if ((_this$globalContext = this.globalContext) !== null && _this$globalContext !== void 0 && _this$globalContext.document) {
            return this.globalContext.document;
          } else if (this.window) {
            return this.window.document;
          } else {
            return void 0;
          }
        }
      }, {
        key: "rootElement",
        get: function get2() {
          var _this$optionsArgs;
          return ((_this$optionsArgs = this.optionsArgs) === null || _this$optionsArgs === void 0 ? void 0 : _this$optionsArgs.rootElement) || this.window;
        }
      }]);
      return OptionsReader2;
    }();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/HTML5BackendImpl.js
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty25(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _classCallCheck19(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties19(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass19(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties19(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties19(Constructor, staticProps);
  return Constructor;
}
function _defineProperty25(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var HTML5BackendImpl;
var init_HTML5BackendImpl = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/HTML5BackendImpl.js"() {
    init_EnterLeaveCounter();
    init_OffsetUtils();
    init_NativeDragSources();
    init_NativeTypes();
    init_OptionsReader();
    HTML5BackendImpl = function() {
      function HTML5BackendImpl2(manager, globalContext, options) {
        var _this = this;
        _classCallCheck19(this, HTML5BackendImpl2);
        _defineProperty25(this, "options", void 0);
        _defineProperty25(this, "actions", void 0);
        _defineProperty25(this, "monitor", void 0);
        _defineProperty25(this, "registry", void 0);
        _defineProperty25(this, "enterLeaveCounter", void 0);
        _defineProperty25(this, "sourcePreviewNodes", /* @__PURE__ */ new Map());
        _defineProperty25(this, "sourcePreviewNodeOptions", /* @__PURE__ */ new Map());
        _defineProperty25(this, "sourceNodes", /* @__PURE__ */ new Map());
        _defineProperty25(this, "sourceNodeOptions", /* @__PURE__ */ new Map());
        _defineProperty25(this, "dragStartSourceIds", null);
        _defineProperty25(this, "dropTargetIds", []);
        _defineProperty25(this, "dragEnterTargetIds", []);
        _defineProperty25(this, "currentNativeSource", null);
        _defineProperty25(this, "currentNativeHandle", null);
        _defineProperty25(this, "currentDragSourceNode", null);
        _defineProperty25(this, "altKeyPressed", false);
        _defineProperty25(this, "mouseMoveTimeoutTimer", null);
        _defineProperty25(this, "asyncEndDragFrameId", null);
        _defineProperty25(this, "dragOverTargetIds", null);
        _defineProperty25(this, "lastClientOffset", null);
        _defineProperty25(this, "hoverRafId", null);
        _defineProperty25(this, "getSourceClientOffset", function(sourceId) {
          var source = _this.sourceNodes.get(sourceId);
          return source && getNodeClientOffset(source) || null;
        });
        _defineProperty25(this, "endDragNativeItem", function() {
          if (!_this.isDraggingNativeItem()) {
            return;
          }
          _this.actions.endDrag();
          if (_this.currentNativeHandle) {
            _this.registry.removeSource(_this.currentNativeHandle);
          }
          _this.currentNativeHandle = null;
          _this.currentNativeSource = null;
        });
        _defineProperty25(this, "isNodeInDocument", function(node) {
          return Boolean(node && _this.document && _this.document.body && _this.document.body.contains(node));
        });
        _defineProperty25(this, "endDragIfSourceWasRemovedFromDOM", function() {
          var node = _this.currentDragSourceNode;
          if (node == null || _this.isNodeInDocument(node)) {
            return;
          }
          if (_this.clearCurrentDragSourceNode() && _this.monitor.isDragging()) {
            _this.actions.endDrag();
          }
        });
        _defineProperty25(this, "handleTopDragStartCapture", function() {
          _this.clearCurrentDragSourceNode();
          _this.dragStartSourceIds = [];
        });
        _defineProperty25(this, "handleTopDragStart", function(e) {
          if (e.defaultPrevented) {
            return;
          }
          var dragStartSourceIds = _this.dragStartSourceIds;
          _this.dragStartSourceIds = null;
          var clientOffset = getEventClientOffset(e);
          if (_this.monitor.isDragging()) {
            _this.actions.endDrag();
          }
          _this.actions.beginDrag(dragStartSourceIds || [], {
            publishSource: false,
            getSourceClientOffset: _this.getSourceClientOffset,
            clientOffset
          });
          var dataTransfer5 = e.dataTransfer;
          var nativeType = matchNativeItemType(dataTransfer5);
          if (_this.monitor.isDragging()) {
            if (dataTransfer5 && typeof dataTransfer5.setDragImage === "function") {
              var sourceId = _this.monitor.getSourceId();
              var sourceNode = _this.sourceNodes.get(sourceId);
              var dragPreview = _this.sourcePreviewNodes.get(sourceId) || sourceNode;
              if (dragPreview) {
                var _this$getCurrentSourc = _this.getCurrentSourcePreviewNodeOptions(), anchorX = _this$getCurrentSourc.anchorX, anchorY = _this$getCurrentSourc.anchorY, offsetX = _this$getCurrentSourc.offsetX, offsetY = _this$getCurrentSourc.offsetY;
                var anchorPoint = {
                  anchorX,
                  anchorY
                };
                var offsetPoint = {
                  offsetX,
                  offsetY
                };
                var dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
                dataTransfer5.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
              }
            }
            try {
              dataTransfer5 === null || dataTransfer5 === void 0 ? void 0 : dataTransfer5.setData("application/json", {});
            } catch (err) {
            }
            _this.setCurrentDragSourceNode(e.target);
            var _this$getCurrentSourc2 = _this.getCurrentSourcePreviewNodeOptions(), captureDraggingState = _this$getCurrentSourc2.captureDraggingState;
            if (!captureDraggingState) {
              setTimeout(function() {
                return _this.actions.publishDragSource();
              }, 0);
            } else {
              _this.actions.publishDragSource();
            }
          } else if (nativeType) {
            _this.beginDragNativeItem(nativeType);
          } else if (dataTransfer5 && !dataTransfer5.types && (e.target && !e.target.hasAttribute || !e.target.hasAttribute("draggable"))) {
            return;
          } else {
            e.preventDefault();
          }
        });
        _defineProperty25(this, "handleTopDragEndCapture", function() {
          if (_this.clearCurrentDragSourceNode() && _this.monitor.isDragging()) {
            _this.actions.endDrag();
          }
        });
        _defineProperty25(this, "handleTopDragEnterCapture", function(e) {
          _this.dragEnterTargetIds = [];
          var isFirstEnter = _this.enterLeaveCounter.enter(e.target);
          if (!isFirstEnter || _this.monitor.isDragging()) {
            return;
          }
          var dataTransfer5 = e.dataTransfer;
          var nativeType = matchNativeItemType(dataTransfer5);
          if (nativeType) {
            _this.beginDragNativeItem(nativeType, dataTransfer5);
          }
        });
        _defineProperty25(this, "handleTopDragEnter", function(e) {
          var dragEnterTargetIds = _this.dragEnterTargetIds;
          _this.dragEnterTargetIds = [];
          if (!_this.monitor.isDragging()) {
            return;
          }
          _this.altKeyPressed = e.altKey;
          if (dragEnterTargetIds.length > 0) {
            _this.actions.hover(dragEnterTargetIds, {
              clientOffset: getEventClientOffset(e)
            });
          }
          var canDrop = dragEnterTargetIds.some(function(targetId) {
            return _this.monitor.canDropOnTarget(targetId);
          });
          if (canDrop) {
            e.preventDefault();
            if (e.dataTransfer) {
              e.dataTransfer.dropEffect = _this.getCurrentDropEffect();
            }
          }
        });
        _defineProperty25(this, "handleTopDragOverCapture", function() {
          _this.dragOverTargetIds = [];
        });
        _defineProperty25(this, "handleTopDragOver", function(e) {
          var dragOverTargetIds = _this.dragOverTargetIds;
          _this.dragOverTargetIds = [];
          if (!_this.monitor.isDragging()) {
            e.preventDefault();
            if (e.dataTransfer) {
              e.dataTransfer.dropEffect = "none";
            }
            return;
          }
          _this.altKeyPressed = e.altKey;
          _this.lastClientOffset = getEventClientOffset(e);
          if (_this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
            _this.hoverRafId = requestAnimationFrame(function() {
              if (_this.monitor.isDragging()) {
                _this.actions.hover(dragOverTargetIds || [], {
                  clientOffset: _this.lastClientOffset
                });
              }
              _this.hoverRafId = null;
            });
          }
          var canDrop = (dragOverTargetIds || []).some(function(targetId) {
            return _this.monitor.canDropOnTarget(targetId);
          });
          if (canDrop) {
            e.preventDefault();
            if (e.dataTransfer) {
              e.dataTransfer.dropEffect = _this.getCurrentDropEffect();
            }
          } else if (_this.isDraggingNativeItem()) {
            e.preventDefault();
          } else {
            e.preventDefault();
            if (e.dataTransfer) {
              e.dataTransfer.dropEffect = "none";
            }
          }
        });
        _defineProperty25(this, "handleTopDragLeaveCapture", function(e) {
          if (_this.isDraggingNativeItem()) {
            e.preventDefault();
          }
          var isLastLeave = _this.enterLeaveCounter.leave(e.target);
          if (!isLastLeave) {
            return;
          }
          if (_this.isDraggingNativeItem()) {
            setTimeout(function() {
              return _this.endDragNativeItem();
            }, 0);
          }
        });
        _defineProperty25(this, "handleTopDropCapture", function(e) {
          _this.dropTargetIds = [];
          if (_this.isDraggingNativeItem()) {
            var _this$currentNativeSo;
            e.preventDefault();
            (_this$currentNativeSo = _this.currentNativeSource) === null || _this$currentNativeSo === void 0 ? void 0 : _this$currentNativeSo.loadDataTransfer(e.dataTransfer);
          } else if (matchNativeItemType(e.dataTransfer)) {
            e.preventDefault();
          }
          _this.enterLeaveCounter.reset();
        });
        _defineProperty25(this, "handleTopDrop", function(e) {
          var dropTargetIds = _this.dropTargetIds;
          _this.dropTargetIds = [];
          _this.actions.hover(dropTargetIds, {
            clientOffset: getEventClientOffset(e)
          });
          _this.actions.drop({
            dropEffect: _this.getCurrentDropEffect()
          });
          if (_this.isDraggingNativeItem()) {
            _this.endDragNativeItem();
          } else if (_this.monitor.isDragging()) {
            _this.actions.endDrag();
          }
        });
        _defineProperty25(this, "handleSelectStart", function(e) {
          var target = e.target;
          if (typeof target.dragDrop !== "function") {
            return;
          }
          if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
            return;
          }
          e.preventDefault();
          target.dragDrop();
        });
        this.options = new OptionsReader(globalContext, options);
        this.actions = manager.getActions();
        this.monitor = manager.getMonitor();
        this.registry = manager.getRegistry();
        this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
      }
      _createClass19(HTML5BackendImpl2, [{
        key: "profile",
        value: function profile() {
          var _this$dragStartSource, _this$dragOverTargetI;
          return {
            sourcePreviewNodes: this.sourcePreviewNodes.size,
            sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
            sourceNodeOptions: this.sourceNodeOptions.size,
            sourceNodes: this.sourceNodes.size,
            dragStartSourceIds: ((_this$dragStartSource = this.dragStartSourceIds) === null || _this$dragStartSource === void 0 ? void 0 : _this$dragStartSource.length) || 0,
            dropTargetIds: this.dropTargetIds.length,
            dragEnterTargetIds: this.dragEnterTargetIds.length,
            dragOverTargetIds: ((_this$dragOverTargetI = this.dragOverTargetIds) === null || _this$dragOverTargetI === void 0 ? void 0 : _this$dragOverTargetI.length) || 0
          };
        }
        // public for test
      }, {
        key: "window",
        get: function get2() {
          return this.options.window;
        }
      }, {
        key: "document",
        get: function get2() {
          return this.options.document;
        }
        /**
         * Get the root element to use for event subscriptions
         */
      }, {
        key: "rootElement",
        get: function get2() {
          return this.options.rootElement;
        }
      }, {
        key: "setup",
        value: function setup() {
          var root = this.rootElement;
          if (root === void 0) {
            return;
          }
          if (root.__isReactDndBackendSetUp) {
            throw new Error("Cannot have two HTML5 backends at the same time.");
          }
          root.__isReactDndBackendSetUp = true;
          this.addEventListeners(root);
        }
      }, {
        key: "teardown",
        value: function teardown() {
          var root = this.rootElement;
          if (root === void 0) {
            return;
          }
          root.__isReactDndBackendSetUp = false;
          this.removeEventListeners(this.rootElement);
          this.clearCurrentDragSourceNode();
          if (this.asyncEndDragFrameId) {
            var _this$window;
            (_this$window = this.window) === null || _this$window === void 0 ? void 0 : _this$window.cancelAnimationFrame(this.asyncEndDragFrameId);
          }
        }
      }, {
        key: "connectDragPreview",
        value: function connectDragPreview(sourceId, node, options) {
          var _this2 = this;
          this.sourcePreviewNodeOptions.set(sourceId, options);
          this.sourcePreviewNodes.set(sourceId, node);
          return function() {
            _this2.sourcePreviewNodes.delete(sourceId);
            _this2.sourcePreviewNodeOptions.delete(sourceId);
          };
        }
      }, {
        key: "connectDragSource",
        value: function connectDragSource(sourceId, node, options) {
          var _this3 = this;
          this.sourceNodes.set(sourceId, node);
          this.sourceNodeOptions.set(sourceId, options);
          var handleDragStart = function handleDragStart2(e) {
            return _this3.handleDragStart(e, sourceId);
          };
          var handleSelectStart = function handleSelectStart2(e) {
            return _this3.handleSelectStart(e);
          };
          node.setAttribute("draggable", "true");
          node.addEventListener("dragstart", handleDragStart);
          node.addEventListener("selectstart", handleSelectStart);
          return function() {
            _this3.sourceNodes.delete(sourceId);
            _this3.sourceNodeOptions.delete(sourceId);
            node.removeEventListener("dragstart", handleDragStart);
            node.removeEventListener("selectstart", handleSelectStart);
            node.setAttribute("draggable", "false");
          };
        }
      }, {
        key: "connectDropTarget",
        value: function connectDropTarget(targetId, node) {
          var _this4 = this;
          var handleDragEnter = function handleDragEnter2(e) {
            return _this4.handleDragEnter(e, targetId);
          };
          var handleDragOver = function handleDragOver2(e) {
            return _this4.handleDragOver(e, targetId);
          };
          var handleDrop = function handleDrop2(e) {
            return _this4.handleDrop(e, targetId);
          };
          node.addEventListener("dragenter", handleDragEnter);
          node.addEventListener("dragover", handleDragOver);
          node.addEventListener("drop", handleDrop);
          return function() {
            node.removeEventListener("dragenter", handleDragEnter);
            node.removeEventListener("dragover", handleDragOver);
            node.removeEventListener("drop", handleDrop);
          };
        }
      }, {
        key: "addEventListeners",
        value: function addEventListeners(target) {
          if (!target.addEventListener) {
            return;
          }
          target.addEventListener("dragstart", this.handleTopDragStart);
          target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
          target.addEventListener("dragend", this.handleTopDragEndCapture, true);
          target.addEventListener("dragenter", this.handleTopDragEnter);
          target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
          target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
          target.addEventListener("dragover", this.handleTopDragOver);
          target.addEventListener("dragover", this.handleTopDragOverCapture, true);
          target.addEventListener("drop", this.handleTopDrop);
          target.addEventListener("drop", this.handleTopDropCapture, true);
        }
      }, {
        key: "removeEventListeners",
        value: function removeEventListeners(target) {
          if (!target.removeEventListener) {
            return;
          }
          target.removeEventListener("dragstart", this.handleTopDragStart);
          target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
          target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
          target.removeEventListener("dragenter", this.handleTopDragEnter);
          target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
          target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
          target.removeEventListener("dragover", this.handleTopDragOver);
          target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
          target.removeEventListener("drop", this.handleTopDrop);
          target.removeEventListener("drop", this.handleTopDropCapture, true);
        }
      }, {
        key: "getCurrentSourceNodeOptions",
        value: function getCurrentSourceNodeOptions() {
          var sourceId = this.monitor.getSourceId();
          var sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
          return _objectSpread6({
            dropEffect: this.altKeyPressed ? "copy" : "move"
          }, sourceNodeOptions || {});
        }
      }, {
        key: "getCurrentDropEffect",
        value: function getCurrentDropEffect() {
          if (this.isDraggingNativeItem()) {
            return "copy";
          }
          return this.getCurrentSourceNodeOptions().dropEffect;
        }
      }, {
        key: "getCurrentSourcePreviewNodeOptions",
        value: function getCurrentSourcePreviewNodeOptions() {
          var sourceId = this.monitor.getSourceId();
          var sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
          return _objectSpread6({
            anchorX: 0.5,
            anchorY: 0.5,
            captureDraggingState: false
          }, sourcePreviewNodeOptions || {});
        }
      }, {
        key: "isDraggingNativeItem",
        value: function isDraggingNativeItem() {
          var itemType = this.monitor.getItemType();
          return Object.keys(NativeTypes_exports).some(function(key) {
            return NativeTypes_exports[key] === itemType;
          });
        }
      }, {
        key: "beginDragNativeItem",
        value: function beginDragNativeItem(type, dataTransfer5) {
          this.clearCurrentDragSourceNode();
          this.currentNativeSource = createNativeDragSource(type, dataTransfer5);
          this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
          this.actions.beginDrag([this.currentNativeHandle]);
        }
      }, {
        key: "setCurrentDragSourceNode",
        value: function setCurrentDragSourceNode(node) {
          var _this5 = this;
          this.clearCurrentDragSourceNode();
          this.currentDragSourceNode = node;
          var MOUSE_MOVE_TIMEOUT = 1e3;
          this.mouseMoveTimeoutTimer = setTimeout(function() {
            var _this5$rootElement;
            return (_this5$rootElement = _this5.rootElement) === null || _this5$rootElement === void 0 ? void 0 : _this5$rootElement.addEventListener("mousemove", _this5.endDragIfSourceWasRemovedFromDOM, true);
          }, MOUSE_MOVE_TIMEOUT);
        }
      }, {
        key: "clearCurrentDragSourceNode",
        value: function clearCurrentDragSourceNode() {
          if (this.currentDragSourceNode) {
            this.currentDragSourceNode = null;
            if (this.rootElement) {
              var _this$window2;
              (_this$window2 = this.window) === null || _this$window2 === void 0 ? void 0 : _this$window2.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
              this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
            }
            this.mouseMoveTimeoutTimer = null;
            return true;
          }
          return false;
        }
      }, {
        key: "handleDragStart",
        value: function handleDragStart(e, sourceId) {
          if (e.defaultPrevented) {
            return;
          }
          if (!this.dragStartSourceIds) {
            this.dragStartSourceIds = [];
          }
          this.dragStartSourceIds.unshift(sourceId);
        }
      }, {
        key: "handleDragEnter",
        value: function handleDragEnter(e, targetId) {
          this.dragEnterTargetIds.unshift(targetId);
        }
      }, {
        key: "handleDragOver",
        value: function handleDragOver(e, targetId) {
          if (this.dragOverTargetIds === null) {
            this.dragOverTargetIds = [];
          }
          this.dragOverTargetIds.unshift(targetId);
        }
      }, {
        key: "handleDrop",
        value: function handleDrop(e, targetId) {
          this.dropTargetIds.unshift(targetId);
        }
      }]);
      return HTML5BackendImpl2;
    }();
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/getEmptyImage.js
function getEmptyImage() {
  if (!emptyImage) {
    emptyImage = new Image();
    emptyImage.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
  }
  return emptyImage;
}
var emptyImage;
var init_getEmptyImage = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/getEmptyImage.js"() {
  }
});

// node_modules/react-dnd-html5-backend/dist/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  HTML5Backend: () => HTML5Backend,
  NativeTypes: () => NativeTypes_exports,
  getEmptyImage: () => getEmptyImage
});
var HTML5Backend;
var init_esm4 = __esm({
  "node_modules/react-dnd-html5-backend/dist/esm/index.js"() {
    init_HTML5BackendImpl();
    init_NativeTypes();
    init_getEmptyImage();
    HTML5Backend = function createBackend(manager, context, options) {
      return new HTML5BackendImpl(manager, context, options);
    };
  }
});

// node_modules/lodash/noop.js
var require_noop = __commonJS({
  "node_modules/lodash/noop.js"(exports, module) {
    function noop2() {
    }
    module.exports = noop2;
  }
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS({
  "node_modules/lodash/_baseFindIndex.js"(exports, module) {
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    module.exports = baseFindIndex;
  }
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS({
  "node_modules/lodash/_baseIsNaN.js"(exports, module) {
    function baseIsNaN(value) {
      return value !== value;
    }
    module.exports = baseIsNaN;
  }
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS({
  "node_modules/lodash/_strictIndexOf.js"(exports, module) {
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    module.exports = strictIndexOf;
  }
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS({
  "node_modules/lodash/_baseIndexOf.js"(exports, module) {
    var baseFindIndex = require_baseFindIndex();
    var baseIsNaN = require_baseIsNaN();
    var strictIndexOf = require_strictIndexOf();
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    module.exports = baseIndexOf;
  }
});

// node_modules/lodash/_arrayIncludes.js
var require_arrayIncludes = __commonJS({
  "node_modules/lodash/_arrayIncludes.js"(exports, module) {
    var baseIndexOf = require_baseIndexOf();
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    module.exports = arrayIncludes;
  }
});

// node_modules/lodash/_arrayIncludesWith.js
var require_arrayIncludesWith = __commonJS({
  "node_modules/lodash/_arrayIncludesWith.js"(exports, module) {
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    module.exports = arrayIncludesWith;
  }
});

// node_modules/lodash/_createSet.js
var require_createSet = __commonJS({
  "node_modules/lodash/_createSet.js"(exports, module) {
    var Set2 = require_Set();
    var noop2 = require_noop();
    var setToArray = require_setToArray();
    var INFINITY = 1 / 0;
    var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values) {
      return new Set2(values);
    };
    module.exports = createSet;
  }
});

// node_modules/lodash/_baseUniq.js
var require_baseUniq = __commonJS({
  "node_modules/lodash/_baseUniq.js"(exports, module) {
    var SetCache = require_SetCache();
    var arrayIncludes = require_arrayIncludes();
    var arrayIncludesWith = require_arrayIncludesWith();
    var cacheHas = require_cacheHas();
    var createSet = require_createSet();
    var setToArray = require_setToArray();
    var LARGE_ARRAY_SIZE = 200;
    function baseUniq(array, iteratee, comparator) {
      var index = -1, includes = arrayIncludes, length = array.length, isCommon = true, result = [], seen = result;
      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      } else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache();
      } else {
        seen = iteratee ? [] : result;
      }
      outer:
        while (++index < length) {
          var value = array[index], computed = iteratee ? iteratee(value) : value;
          value = comparator || value !== 0 ? value : 0;
          if (isCommon && computed === computed) {
            var seenIndex = seen.length;
            while (seenIndex--) {
              if (seen[seenIndex] === computed) {
                continue outer;
              }
            }
            if (iteratee) {
              seen.push(computed);
            }
            result.push(value);
          } else if (!includes(seen, computed, comparator)) {
            if (seen !== result) {
              seen.push(computed);
            }
            result.push(value);
          }
        }
      return result;
    }
    module.exports = baseUniq;
  }
});

// node_modules/lodash/uniq.js
var require_uniq = __commonJS({
  "node_modules/lodash/uniq.js"(exports, module) {
    var baseUniq = require_baseUniq();
    function uniq(array) {
      return array && array.length ? baseUniq(array) : [];
    }
    module.exports = uniq;
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has = require_has();
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has;
    function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has(typeSpecs, typeSpecName)) {
            var error;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error = ex;
            }
            if (error && !(error instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error instanceof Error && !(error.message in loggedTypeFailures)) {
              loggedTypeFailures[error.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text2) {
        var message = "Warning: " + text2;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error instanceof Error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has(propValue, key)) {
              var error = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error instanceof Error) {
                return error;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error) {
              return error;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/react-tag-input/dist-modules/components/ClearAllTags.js
var require_ClearAllTags = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/ClearAllTags.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var ClearAllTags = function ClearAllTags2(props) {
      return _react["default"].createElement("button", {
        className: props.classNames.clearAll,
        onClick: props.onClick
      }, "Clear all");
    };
    ClearAllTags.propTypes = {
      classNames: _propTypes["default"].object,
      onClick: _propTypes["default"].func
    };
    var _default = exports["default"] = ClearAllTags;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports, module) {
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    module.exports = basePropertyOf;
  }
});

// node_modules/lodash/_escapeHtmlChar.js
var require_escapeHtmlChar = __commonJS({
  "node_modules/lodash/_escapeHtmlChar.js"(exports, module) {
    var basePropertyOf = require_basePropertyOf();
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    module.exports = escapeHtmlChar;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports, module) {
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    module.exports = arrayMap;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports, module) {
    var baseGetTag = require_baseGetTag();
    var isObjectLike2 = require_isObjectLike();
    var symbolTag = "[object Symbol]";
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike2(value) && baseGetTag(value) == symbolTag;
    }
    module.exports = isSymbol;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports, module) {
    var Symbol2 = require_Symbol();
    var arrayMap = require_arrayMap();
    var isArray = require_isArray();
    var isSymbol = require_isSymbol();
    var INFINITY = 1 / 0;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray(value)) {
        return arrayMap(value, baseToString) + "";
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    module.exports = baseToString;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports, module) {
    var baseToString = require_baseToString();
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    module.exports = toString;
  }
});

// node_modules/lodash/escape.js
var require_escape = __commonJS({
  "node_modules/lodash/escape.js"(exports, module) {
    var escapeHtmlChar = require_escapeHtmlChar();
    var toString = require_toString();
    var reUnescapedHtml = /[&<>"']/g;
    var reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    function escape(string) {
      string = toString(string);
      return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
    }
    module.exports = escape;
  }
});

// node_modules/react-tag-input/dist-modules/components/Suggestions.js
var require_Suggestions = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/Suggestions.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _isEqual = _interopRequireDefault(require_isEqual());
    var _escape = _interopRequireDefault(require_escape());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != _typeof9(e) && "function" != typeof e)
        return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _typeof9(o) {
      "@babel/helpers - typeof";
      return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof9(o);
    }
    function _classCallCheck20(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties20(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass20(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties20(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties20(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf3(subClass, superClass);
    }
    function _setPrototypeOf3(o, p) {
      _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf3(o, p);
    }
    function _createSuper3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf3(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf3(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn3(this, result);
      };
    }
    function _possibleConstructorReturn3(self2, call) {
      if (call && (_typeof9(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized3(self2);
    }
    function _assertThisInitialized3(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct3() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf3(o) {
      _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf4(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf3(o);
    }
    function _defineProperty26(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof9(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof9(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof9(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var maybeScrollSuggestionIntoView = function maybeScrollSuggestionIntoView2(suggestionEl, suggestionsContainer) {
      var containerHeight = suggestionsContainer.offsetHeight;
      var suggestionHeight = suggestionEl.offsetHeight;
      var relativeSuggestionTop = suggestionEl.offsetTop - suggestionsContainer.scrollTop;
      if (relativeSuggestionTop + suggestionHeight >= containerHeight) {
        suggestionsContainer.scrollTop += relativeSuggestionTop - containerHeight + suggestionHeight;
      } else if (relativeSuggestionTop < 0) {
        suggestionsContainer.scrollTop += relativeSuggestionTop;
      }
    };
    var Suggestions = function(_Component) {
      _inherits3(Suggestions2, _Component);
      var _super = _createSuper3(Suggestions2);
      function Suggestions2() {
        var _this;
        _classCallCheck20(this, Suggestions2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty26(_assertThisInitialized3(_this), "markIt", function(input, query) {
          var escapedRegex = query.trim().replace(/[-\\^$*+?.()|[\]{}]/g, "\\$&");
          var labelValue = input[_this.props.labelField];
          return {
            __html: labelValue.replace(RegExp(escapedRegex, "gi"), function(x) {
              return "<mark>".concat((0, _escape["default"])(x), "</mark>");
            })
          };
        });
        _defineProperty26(_assertThisInitialized3(_this), "shouldRenderSuggestions", function(query) {
          var _this$props = _this.props, minQueryLength = _this$props.minQueryLength, isFocused = _this$props.isFocused;
          return query.length >= minQueryLength && isFocused;
        });
        _defineProperty26(_assertThisInitialized3(_this), "renderSuggestion", function(item, query) {
          var renderSuggestion = _this.props.renderSuggestion;
          if (typeof renderSuggestion === "function") {
            return renderSuggestion(item, query);
          }
          return _react["default"].createElement("span", {
            dangerouslySetInnerHTML: _this.markIt(item, query)
          });
        });
        return _this;
      }
      _createClass20(Suggestions2, [{
        key: "shouldComponentUpdate",
        value: function shouldComponentUpdate(nextProps) {
          var props = this.props;
          var shouldRenderSuggestions = props.shouldRenderSuggestions || this.shouldRenderSuggestions;
          return props.isFocused !== nextProps.isFocused || !(0, _isEqual["default"])(props.suggestions, nextProps.suggestions) || shouldRenderSuggestions(nextProps.query) || shouldRenderSuggestions(nextProps.query) !== shouldRenderSuggestions(props.query);
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          var _this$props2 = this.props, selectedIndex = _this$props2.selectedIndex, classNames = _this$props2.classNames;
          if (this.suggestionsContainer && prevProps.selectedIndex !== selectedIndex) {
            var activeSuggestion = this.suggestionsContainer.querySelector(".".concat(classNames.activeSuggestion));
            if (activeSuggestion) {
              maybeScrollSuggestionIntoView(activeSuggestion, this.suggestionsContainer);
            }
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this2 = this;
          var props = this.props;
          var suggestions = props.suggestions.map((function(item, i) {
            return _react["default"].createElement("li", {
              key: i,
              onMouseDown: props.handleClick.bind(null, i),
              onTouchStart: props.handleClick.bind(null, i),
              onMouseOver: props.handleHover.bind(null, i),
              className: i === props.selectedIndex ? props.classNames.activeSuggestion : ""
            }, this.renderSuggestion(item, props.query));
          }).bind(this));
          var shouldRenderSuggestions = props.shouldRenderSuggestions || this.shouldRenderSuggestions;
          if (suggestions.length === 0 || !shouldRenderSuggestions(props.query)) {
            return null;
          }
          return _react["default"].createElement("div", {
            ref: function ref(elem) {
              _this2.suggestionsContainer = elem;
            },
            className: this.props.classNames.suggestions
          }, _react["default"].createElement("ul", null, " ", suggestions, " "));
        }
      }]);
      return Suggestions2;
    }(_react.Component);
    _defineProperty26(Suggestions, "propTypes", {
      query: _propTypes["default"].string.isRequired,
      selectedIndex: _propTypes["default"].number.isRequired,
      suggestions: _propTypes["default"].array.isRequired,
      handleClick: _propTypes["default"].func.isRequired,
      handleHover: _propTypes["default"].func.isRequired,
      minQueryLength: _propTypes["default"].number,
      shouldRenderSuggestions: _propTypes["default"].func,
      isFocused: _propTypes["default"].bool.isRequired,
      classNames: _propTypes["default"].object,
      labelField: _propTypes["default"].string.isRequired,
      renderSuggestion: _propTypes["default"].func
    });
    _defineProperty26(Suggestions, "defaultProps", {
      minQueryLength: 2
    });
    var _default = exports["default"] = Suggestions;
  }
});

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (typeof module !== "undefined" && module.exports) {
        classNames.default = classNames;
        module.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/lodash/escapeRegExp.js
var require_escapeRegExp = __commonJS({
  "node_modules/lodash/escapeRegExp.js"(exports, module) {
    var toString = require_toString();
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reHasRegExpChar = RegExp(reRegExpChar.source);
    function escapeRegExp(string) {
      string = toString(string);
      return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
    }
    module.exports = escapeRegExp;
  }
});

// node_modules/react-tag-input/dist-modules/components/utils.js
var require_utils = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.buildRegExpFromDelimiters = buildRegExpFromDelimiters;
    exports.canDrag = canDrag;
    exports.canDrop = canDrop;
    var _escapeRegExp = _interopRequireDefault(require_escapeRegExp());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function buildRegExpFromDelimiters(delimiters) {
      var delimiterChars = delimiters.map(function(delimiter) {
        var chrCode = delimiter - 48 * Math.floor(delimiter / 48);
        return String.fromCharCode(96 <= delimiter ? chrCode : delimiter);
      }).join("");
      var escapedDelimiterChars = (0, _escapeRegExp["default"])(delimiterChars);
      return new RegExp("[".concat(escapedDelimiterChars, "]+"));
    }
    function canDrag(params) {
      var moveTag = params.moveTag, readOnly = params.readOnly, allowDragDrop = params.allowDragDrop;
      return moveTag !== void 0 && !readOnly && allowDragDrop;
    }
    function canDrop(params) {
      var readOnly = params.readOnly, allowDragDrop = params.allowDragDrop;
      return !readOnly && allowDragDrop;
    }
  }
});

// node_modules/react-tag-input/dist-modules/components/constants.js
var require_constants = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/constants.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.KEYS = exports.INPUT_FIELD_POSITIONS = exports.ERRORS = exports.DEFAULT_PLACEHOLDER = exports.DEFAULT_LABEL_FIELD = exports.DEFAULT_CLASSNAMES = void 0;
    var KEYS = exports.KEYS = {
      ENTER: [10, 13],
      TAB: 9,
      BACKSPACE: 8,
      UP_ARROW: 38,
      DOWN_ARROW: 40,
      ESCAPE: 27,
      SPACE: 32,
      COMMA: 188
    };
    var DEFAULT_PLACEHOLDER = exports.DEFAULT_PLACEHOLDER = "Press enter to add new tag";
    var DEFAULT_LABEL_FIELD = exports.DEFAULT_LABEL_FIELD = "text";
    var DEFAULT_CLASSNAMES = exports.DEFAULT_CLASSNAMES = {
      tags: "ReactTags__tags",
      tagInput: "ReactTags__tagInput",
      tagInputField: "ReactTags__tagInputField",
      selected: "ReactTags__selected",
      tag: "ReactTags__tag",
      remove: "ReactTags__remove",
      suggestions: "ReactTags__suggestions",
      activeSuggestion: "ReactTags__activeSuggestion",
      editTagInput: "ReactTags__editTagInput",
      editTagInputField: "ReactTags__editTagInputField",
      clearAll: "ReactTags__clearAll"
    };
    var INPUT_FIELD_POSITIONS = exports.INPUT_FIELD_POSITIONS = {
      INLINE: "inline",
      TOP: "top",
      BOTTOM: "bottom"
    };
    var ERRORS = exports.ERRORS = {
      TAG_LIMIT: "Tag limit reached!"
    };
  }
});

// node_modules/react-tag-input/dist-modules/components/RemoveComponent.js
var require_RemoveComponent = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/RemoveComponent.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireDefault(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var crossStr = String.fromCharCode(215);
    var RemoveComponent = function RemoveComponent2(props) {
      var readOnly = props.readOnly, removeComponent = props.removeComponent, onRemove = props.onRemove, className = props.className, tag = props.tag, index = props.index;
      var onKeydown = function onKeydown2(event) {
        if (_constants.KEYS.ENTER.includes(event.keyCode) || event.keyCode === _constants.KEYS.SPACE) {
          event.preventDefault();
          event.stopPropagation();
          return;
        }
        if (event.keyCode === _constants.KEYS.BACKSPACE) {
          onRemove(event);
        }
      };
      if (readOnly) {
        return _react["default"].createElement("span", null);
      }
      var ariaLabel = "Tag at index ".concat(index, " with value ").concat(tag.id, " focussed. Press backspace to remove");
      if (removeComponent) {
        var Component3 = removeComponent;
        return _react["default"].createElement(Component3, {
          onRemove,
          onKeyDown: onKeydown,
          className,
          "aria-label": ariaLabel,
          tag,
          index
        });
      }
      return _react["default"].createElement("button", {
        onClick: onRemove,
        onKeyDown: onKeydown,
        className,
        type: "button",
        "aria-label": ariaLabel
      }, crossStr);
    };
    RemoveComponent.propTypes = {
      className: _propTypes["default"].string,
      onRemove: _propTypes["default"].func.isRequired,
      readOnly: _propTypes["default"].bool,
      removeComponent: _propTypes["default"].func,
      tag: _propTypes["default"].shape({
        id: _propTypes["default"].string.isRequired,
        className: _propTypes["default"].string,
        key: _propTypes["default"].string
      }),
      index: _propTypes["default"].number.isRequired
    };
    var _default = exports["default"] = RemoveComponent;
  }
});

// node_modules/react-tag-input/dist-modules/components/Tag.js
var require_Tag = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/Tag.js"(exports) {
    "use strict";
    function _typeof9(o) {
      "@babel/helpers - typeof";
      return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof9(o);
    }
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _reactDnd = (init_esm3(), __toCommonJS(esm_exports));
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _classnames = _interopRequireDefault(require_classnames());
    var _utils = require_utils();
    var _RemoveComponent = _interopRequireDefault(require_RemoveComponent());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != _typeof9(e) && "function" != typeof e)
        return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _slicedToArray9(arr, i) {
      return _arrayWithHoles9(arr) || _iterableToArrayLimit9(arr, i) || _unsupportedIterableToArray10(arr, i) || _nonIterableRest9();
    }
    function _nonIterableRest9() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray10(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray10(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray10(o, minLen);
    }
    function _arrayLikeToArray10(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _iterableToArrayLimit9(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e, n, i, u, a = [], f = true, o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t)
              return;
            f = false;
          } else
            for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true)
              ;
        } catch (r2) {
          o = true, n = r2;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u))
              return;
          } finally {
            if (o)
              throw n;
          }
        }
        return a;
      }
    }
    function _arrayWithHoles9(arr) {
      if (Array.isArray(arr))
        return arr;
    }
    var ItemTypes = {
      TAG: "tag"
    };
    var Tag = function Tag2(props) {
      var tagRef = (0, _react.useRef)(null);
      var readOnly = props.readOnly, tag = props.tag, classNames = props.classNames, index = props.index;
      var _useDrag = (0, _reactDnd.useDrag)(function() {
        return {
          type: ItemTypes.TAG,
          collect: function collect(monitor) {
            return {
              isDragging: !!monitor.isDragging()
            };
          },
          item: props,
          canDrag: function canDrag() {
            return (0, _utils.canDrag)(props);
          }
        };
      }), _useDrag2 = _slicedToArray9(_useDrag, 2), isDragging = _useDrag2[0].isDragging, drag = _useDrag2[1];
      var _useDrop = (0, _reactDnd.useDrop)(function() {
        return {
          accept: ItemTypes.TAG,
          drop: function drop2(item, monitor) {
            var dragIndex = item.index;
            var hoverIndex = index;
            if (dragIndex === hoverIndex) {
              return;
            }
            props.moveTag(dragIndex, hoverIndex);
          },
          canDrop: function canDrop(item) {
            return (0, _utils.canDrop)(item);
          }
        };
      }), _useDrop2 = _slicedToArray9(_useDrop, 2), drop = _useDrop2[1];
      drag(drop(tagRef));
      var label = props.tag[props.labelField];
      var _tag$className = tag.className, className = _tag$className === void 0 ? "" : _tag$className;
      var opacity = isDragging ? 0 : 1;
      var tagComponent = _react["default"].createElement("span", {
        ref: tagRef,
        className: (0, _classnames["default"])("tag-wrapper", classNames.tag, className),
        style: {
          opacity,
          cursor: (0, _utils.canDrag)(props) ? "move" : "auto"
        },
        onClick: props.onTagClicked,
        onTouchStart: props.onTagClicked
      }, label, _react["default"].createElement(_RemoveComponent["default"], {
        tag: props.tag,
        className: classNames.remove,
        removeComponent: props.removeComponent,
        onRemove: props.onDelete,
        readOnly,
        index
      }));
      return tagComponent;
    };
    Tag.propTypes = {
      labelField: _propTypes["default"].string,
      onDelete: _propTypes["default"].func.isRequired,
      tag: _propTypes["default"].shape({
        id: _propTypes["default"].string.isRequired,
        className: _propTypes["default"].string,
        key: _propTypes["default"].string
      }),
      moveTag: _propTypes["default"].func,
      removeComponent: _propTypes["default"].func,
      onTagClicked: _propTypes["default"].func,
      classNames: _propTypes["default"].object,
      readOnly: _propTypes["default"].bool,
      index: _propTypes["default"].number.isRequired
    };
    Tag.defaultProps = {
      labelField: "text",
      readOnly: false
    };
    var _default = exports["default"] = Tag;
  }
});

// node_modules/react-tag-input/dist-modules/components/ReactTags.js
var require_ReactTags = __commonJS({
  "node_modules/react-tag-input/dist-modules/components/ReactTags.js"(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "KEYS", {
      enumerable: true,
      get: function get2() {
        return _constants.KEYS;
      }
    });
    exports.WithOutContext = exports.WithContext = void 0;
    var _react = _interopRequireWildcard(require_react());
    var _reactDnd = (init_esm3(), __toCommonJS(esm_exports));
    var _reactDndHtml5Backend = (init_esm4(), __toCommonJS(esm_exports2));
    var _isEqual = _interopRequireDefault(require_isEqual());
    var _noop = _interopRequireDefault(require_noop());
    var _uniq = _interopRequireDefault(require_uniq());
    var _ClearAllTags = _interopRequireDefault(require_ClearAllTags());
    var _Suggestions = _interopRequireDefault(require_Suggestions());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _classnames = _interopRequireDefault(require_classnames());
    var _Tag = _interopRequireDefault(require_Tag());
    var _utils = require_utils();
    var _constants = require_constants();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap)
        return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule)
        return e;
      if (null === e || "object" != _typeof9(e) && "function" != typeof e)
        return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e))
        return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e)
        if ("default" !== u && Object.prototype.hasOwnProperty.call(e, u)) {
          var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
          i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
        }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _toConsumableArray2(arr) {
      return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray10(arr) || _nonIterableSpread2();
    }
    function _nonIterableSpread2() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function _unsupportedIterableToArray10(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray10(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray10(o, minLen);
    }
    function _iterableToArray2(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _arrayWithoutHoles2(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray10(arr);
    }
    function _arrayLikeToArray10(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _typeof9(o) {
      "@babel/helpers - typeof";
      return _typeof9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof9(o);
    }
    function _objectDestructuringEmpty(obj) {
      if (obj == null)
        throw new TypeError("Cannot destructure " + obj);
    }
    function _extends() {
      _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      return _extends.apply(this, arguments);
    }
    function ownKeys6(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread7(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys6(Object(t), true).forEach(function(r2) {
          _defineProperty26(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys6(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _classCallCheck20(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties20(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    function _createClass20(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties20(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties20(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", { writable: false });
      return Constructor;
    }
    function _inherits3(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      Object.defineProperty(subClass, "prototype", { writable: false });
      if (superClass)
        _setPrototypeOf3(subClass, superClass);
    }
    function _setPrototypeOf3(o, p) {
      _setPrototypeOf3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf4(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf3(o, p);
    }
    function _createSuper3(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct3();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf3(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf3(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn3(this, result);
      };
    }
    function _possibleConstructorReturn3(self2, call) {
      if (call && (_typeof9(call) === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized3(self2);
    }
    function _assertThisInitialized3(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _isNativeReflectConstruct3() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf3(o) {
      _getPrototypeOf3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf4(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf3(o);
    }
    function _defineProperty26(obj, key, value) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return _typeof9(key) === "symbol" ? key : String(key);
    }
    function _toPrimitive(input, hint) {
      if (_typeof9(input) !== "object" || input === null)
        return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (_typeof9(res) !== "object")
          return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    var ReactTags = exports.WithOutContext = function(_Component) {
      _inherits3(ReactTags2, _Component);
      var _super = _createSuper3(ReactTags2);
      function ReactTags2(props) {
        var _this;
        _classCallCheck20(this, ReactTags2);
        _this = _super.call(this, props);
        _defineProperty26(_assertThisInitialized3(_this), "filteredSuggestions", function(query) {
          var suggestions = _this.props.suggestions;
          if (_this.props.allowUnique) {
            var existingTags = _this.props.tags.map(function(tag) {
              return tag.id.trim().toLowerCase();
            });
            suggestions = suggestions.filter(function(suggestion) {
              return !existingTags.includes(suggestion.id.toLowerCase());
            });
          }
          if (_this.props.handleFilterSuggestions) {
            return _this.props.handleFilterSuggestions(query, suggestions);
          }
          var exactSuggestions = suggestions.filter(function(item) {
            return _this.getQueryIndex(query, item) === 0;
          });
          var partialSuggestions = suggestions.filter(function(item) {
            return _this.getQueryIndex(query, item) > 0;
          });
          return exactSuggestions.concat(partialSuggestions);
        });
        _defineProperty26(_assertThisInitialized3(_this), "getQueryIndex", function(query, item) {
          return item[_this.props.labelField].toLowerCase().indexOf(query.toLowerCase());
        });
        _defineProperty26(_assertThisInitialized3(_this), "resetAndFocusInput", function() {
          _this.setState({
            query: ""
          });
          if (_this.textInput) {
            _this.textInput.value = "";
            _this.textInput.focus();
          }
        });
        _defineProperty26(_assertThisInitialized3(_this), "updateSuggestions", function() {
          var _this$state = _this.state, query = _this$state.query, selectedIndex = _this$state.selectedIndex;
          var suggestions = _this.filteredSuggestions(query);
          _this.setState({
            suggestions,
            selectedIndex: selectedIndex >= suggestions.length ? suggestions.length - 1 : selectedIndex
          });
        });
        _defineProperty26(_assertThisInitialized3(_this), "addTag", function(tag) {
          var _this$props = _this.props, tags = _this$props.tags, labelField = _this$props.labelField, allowUnique = _this$props.allowUnique;
          var currentEditIndex = _this.state.currentEditIndex;
          if (!tag.id || !tag[labelField]) {
            return;
          }
          if (currentEditIndex === -1) {
            if (_this.tagLimitReached()) {
              _this.setState({
                error: _constants.ERRORS.TAG_LIMIT
              });
              _this.resetAndFocusInput();
              return;
            }
            _this.setState({
              error: ""
            });
          }
          var existingKeys = tags.map(function(tag2) {
            return tag2.id.toLowerCase();
          });
          if (allowUnique && existingKeys.indexOf(tag.id.trim().toLowerCase()) >= 0) {
            return;
          }
          if (_this.props.autocomplete) {
            var possibleMatches = _this.filteredSuggestions(tag[labelField]);
            if (_this.props.autocomplete === 1 && possibleMatches.length === 1 || _this.props.autocomplete === true && possibleMatches.length) {
              tag = possibleMatches[0];
            }
          }
          if (currentEditIndex !== -1 && _this.props.onTagUpdate)
            _this.props.onTagUpdate(currentEditIndex, tag);
          else
            _this.props.handleAddition(tag);
          _this.setState({
            query: "",
            selectionMode: false,
            selectedIndex: -1,
            currentEditIndex: -1
          });
          _this.resetAndFocusInput();
        });
        _defineProperty26(_assertThisInitialized3(_this), "clearAll", function() {
          if (_this.props.onClearAll) {
            _this.props.onClearAll();
          }
          _this.setState({
            error: ""
          });
        });
        _defineProperty26(_assertThisInitialized3(_this), "getTagItems", function() {
          var _this$props2 = _this.props, tags = _this$props2.tags, labelField = _this$props2.labelField, removeComponent = _this$props2.removeComponent, readOnly = _this$props2.readOnly, allowDragDrop = _this$props2.allowDragDrop;
          var classNames = _objectSpread7(_objectSpread7({}, _constants.DEFAULT_CLASSNAMES), _this.props.classNames);
          var _this$state2 = _this.state, currentEditIndex = _this$state2.currentEditIndex, query = _this$state2.query;
          var moveTag = allowDragDrop ? _this.moveTag : null;
          return tags.map(function(tag, index) {
            return _react["default"].createElement(_react["default"].Fragment, {
              key: index
            }, currentEditIndex === index ? _react["default"].createElement("div", {
              className: classNames.editTagInput
            }, _react["default"].createElement("input", {
              ref: function ref(input) {
                _this.tagInput = input;
              },
              onFocus: _this.handleFocus,
              value: query,
              onChange: _this.handleChange,
              onKeyDown: _this.handleKeyDown,
              onBlur: _this.handleBlur,
              className: classNames.editTagInputField,
              onPaste: _this.handlePaste,
              "data-testid": "tag-edit"
            })) : _react["default"].createElement(_Tag["default"], {
              index,
              tag,
              labelField,
              onDelete: _this.handleDelete.bind(_assertThisInitialized3(_this), index),
              moveTag,
              removeComponent,
              onTagClicked: _this.handleTagClick.bind(_assertThisInitialized3(_this), index, tag),
              readOnly,
              classNames,
              allowDragDrop
            }));
          });
        });
        if (!props.inline) {
          console.warn("[Deprecation] The inline attribute is deprecated and will be removed in v7.x.x, please use inputFieldPosition instead.");
        }
        var _suggestions = props.suggestions;
        _this.state = {
          suggestions: _suggestions,
          query: "",
          isFocused: false,
          selectedIndex: -1,
          selectionMode: false,
          ariaLiveStatus: "",
          currentEditIndex: -1,
          error: ""
        };
        _this.reactTagsRef = (0, _react.createRef)();
        _this.handleFocus = _this.handleFocus.bind(_assertThisInitialized3(_this));
        _this.handleBlur = _this.handleBlur.bind(_assertThisInitialized3(_this));
        _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized3(_this));
        _this.handleChange = _this.handleChange.bind(_assertThisInitialized3(_this));
        _this.moveTag = _this.moveTag.bind(_assertThisInitialized3(_this));
        _this.handlePaste = _this.handlePaste.bind(_assertThisInitialized3(_this));
        _this.handleSuggestionHover = _this.handleSuggestionHover.bind(_assertThisInitialized3(_this));
        _this.handleSuggestionClick = _this.handleSuggestionClick.bind(_assertThisInitialized3(_this));
        return _this;
      }
      _createClass20(ReactTags2, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props3 = this.props, autofocus = _this$props3.autofocus, readOnly = _this$props3.readOnly;
          if (autofocus && !readOnly) {
            this.resetAndFocusInput();
          }
        }
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps) {
          if (!(0, _isEqual["default"])(prevProps.suggestions, this.props.suggestions)) {
            this.updateSuggestions();
          }
        }
      }, {
        key: "handleDelete",
        value: function handleDelete(index, event) {
          event.preventDefault();
          event.stopPropagation();
          var currentTags = this.props.tags.slice();
          if (currentTags.length === 0) {
            return;
          }
          this.setState({
            error: ""
          });
          var ariaLiveStatus = "Tag at index ".concat(index, " with value ").concat(currentTags[index].id, " deleted.");
          this.props.handleDelete(index, event);
          var allTags = this.reactTagsRef.current.querySelectorAll(".ReactTags__remove");
          var nextElementToFocus, nextIndex, nextTag;
          if (index === 0 && currentTags.length > 1) {
            nextElementToFocus = allTags[0];
            nextIndex = 0;
            nextTag = currentTags[1];
          } else {
            nextElementToFocus = allTags[index - 1];
            nextIndex = index - 1;
            nextTag = currentTags[nextIndex];
          }
          if (!nextElementToFocus) {
            nextIndex = -1;
            nextElementToFocus = this.textInput;
          }
          if (nextIndex >= 0) {
            ariaLiveStatus += " Tag at index ".concat(nextIndex, " with value ").concat(nextTag.id, " focussed. Press backspace to remove");
          } else {
            ariaLiveStatus += "Input focussed. Press enter to add a new tag";
          }
          nextElementToFocus.focus();
          this.setState({
            ariaLiveStatus
          });
        }
      }, {
        key: "handleTagClick",
        value: function handleTagClick(i, tag, e) {
          var _this2 = this;
          var _this$props4 = this.props, editable = _this$props4.editable, handleTagClick2 = _this$props4.handleTagClick, labelField = _this$props4.labelField;
          if (editable) {
            this.setState({
              currentEditIndex: i,
              query: tag[labelField]
            }, function() {
              _this2.tagInput.focus();
            });
          }
          if (handleTagClick2) {
            handleTagClick2(i, e);
          }
        }
      }, {
        key: "handleChange",
        value: function handleChange(e) {
          if (this.props.handleInputChange) {
            this.props.handleInputChange(e.target.value, e);
          }
          var query = e.target.value.trim();
          this.setState({
            query
          }, this.updateSuggestions);
        }
      }, {
        key: "handleFocus",
        value: function handleFocus(event) {
          var value = event.target.value;
          if (this.props.handleInputFocus) {
            this.props.handleInputFocus(value, event);
          }
          this.setState({
            isFocused: true
          });
        }
      }, {
        key: "handleBlur",
        value: function handleBlur(event) {
          var value = event.target.value;
          if (this.props.handleInputBlur) {
            this.props.handleInputBlur(value, event);
            if (this.textInput) {
              this.textInput.value = "";
            }
          }
          this.setState({
            isFocused: false,
            currentEditIndex: -1
          });
        }
      }, {
        key: "handleKeyDown",
        value: function handleKeyDown(e) {
          var _this$state3 = this.state, query = _this$state3.query, selectedIndex = _this$state3.selectedIndex, suggestions = _this$state3.suggestions, selectionMode = _this$state3.selectionMode;
          if (e.keyCode === _constants.KEYS.ESCAPE) {
            e.preventDefault();
            e.stopPropagation();
            this.setState({
              selectedIndex: -1,
              selectionMode: false,
              suggestions: [],
              currentEditIndex: -1
            });
          }
          if (this.props.delimiters.indexOf(e.keyCode) !== -1 && !e.shiftKey) {
            if (e.keyCode !== _constants.KEYS.TAB || query !== "") {
              e.preventDefault();
            }
            var selectedQuery = selectionMode && selectedIndex !== -1 ? suggestions[selectedIndex] : _defineProperty26({
              id: query.trim()
            }, this.props.labelField, query.trim());
            if (Object.keys(selectedQuery)) {
              this.addTag(selectedQuery);
            }
          }
          if (e.keyCode === _constants.KEYS.BACKSPACE && query === "" && this.props.allowDeleteFromEmptyInput) {
            this.handleDelete(this.props.tags.length - 1, e);
          }
          if (e.keyCode === _constants.KEYS.UP_ARROW) {
            e.preventDefault();
            this.setState({
              selectedIndex: selectedIndex <= 0 ? suggestions.length - 1 : selectedIndex - 1,
              selectionMode: true
            });
          }
          if (e.keyCode === _constants.KEYS.DOWN_ARROW) {
            e.preventDefault();
            this.setState({
              selectedIndex: suggestions.length === 0 ? -1 : (selectedIndex + 1) % suggestions.length,
              selectionMode: true
            });
          }
        }
      }, {
        key: "tagLimitReached",
        value: function tagLimitReached() {
          var _this$props5 = this.props, tags = _this$props5.tags, maxTags = _this$props5.maxTags;
          return maxTags && tags.length >= maxTags;
        }
      }, {
        key: "handlePaste",
        value: function handlePaste(e) {
          var _this3 = this;
          if (!this.props.allowAdditionFromPaste) {
            return;
          }
          if (this.tagLimitReached()) {
            this.setState({
              error: _constants.ERRORS.TAG_LIMIT
            });
            this.resetAndFocusInput();
            return;
          }
          this.setState({
            error: ""
          });
          e.preventDefault();
          var clipboardData = e.clipboardData || window.clipboardData;
          var clipboardText = clipboardData.getData("text");
          var _this$props$maxLength = this.props.maxLength, maxLength = _this$props$maxLength === void 0 ? clipboardText.length : _this$props$maxLength;
          var maxTextLength = Math.min(maxLength, clipboardText.length);
          var pastedText = clipboardData.getData("text").substr(0, maxTextLength);
          var delimiterRegExp = (0, _utils.buildRegExpFromDelimiters)(this.props.delimiters);
          var tags = pastedText.split(delimiterRegExp).map(function(tag) {
            return tag.trim();
          });
          (0, _uniq["default"])(tags).forEach(function(tag) {
            return _this3.addTag(_defineProperty26({
              id: tag.trim()
            }, _this3.props.labelField, tag.trim()));
          });
        }
      }, {
        key: "handleSuggestionClick",
        value: function handleSuggestionClick(i) {
          this.addTag(this.state.suggestions[i]);
        }
      }, {
        key: "handleSuggestionHover",
        value: function handleSuggestionHover(i) {
          this.setState({
            selectedIndex: i,
            selectionMode: true
          });
        }
      }, {
        key: "moveTag",
        value: function moveTag(dragIndex, hoverIndex) {
          var tags = this.props.tags;
          var dragTag = tags[dragIndex];
          this.props.handleDrag(dragTag, dragIndex, hoverIndex);
        }
      }, {
        key: "render",
        value: function render() {
          var _this4 = this;
          var tagItems = this.getTagItems();
          var classNames = _objectSpread7(_objectSpread7({}, _constants.DEFAULT_CLASSNAMES), this.props.classNames);
          var query = this.state.query.trim(), selectedIndex = this.state.selectedIndex, suggestions = this.state.suggestions, error = this.state.error;
          var _this$props6 = this.props, placeholder = _this$props6.placeholder, inputName = _this$props6.name, inputId = _this$props6.id, maxLength = _this$props6.maxLength, inline = _this$props6.inline, inputFieldPosition = _this$props6.inputFieldPosition, inputValue = _this$props6.inputValue, inputProps = _this$props6.inputProps, clearAll = _this$props6.clearAll, tags = _this$props6.tags;
          var position = !inline ? _constants.INPUT_FIELD_POSITIONS.BOTTOM : inputFieldPosition;
          var tagInput = !this.props.readOnly ? _react["default"].createElement("div", {
            className: classNames.tagInput
          }, _react["default"].createElement("input", _extends({}, inputProps, {
            ref: function ref(input) {
              _this4.textInput = input;
            },
            className: classNames.tagInputField,
            type: "text",
            placeholder,
            "aria-label": placeholder,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            onChange: this.handleChange,
            onKeyDown: this.handleKeyDown,
            onPaste: this.handlePaste,
            name: inputName,
            id: inputId,
            maxLength,
            value: inputValue,
            "data-automation": "input",
            "data-testid": "input"
          })), _react["default"].createElement(_Suggestions["default"], {
            query,
            suggestions,
            labelField: this.props.labelField,
            selectedIndex,
            handleClick: this.handleSuggestionClick,
            handleHover: this.handleSuggestionHover,
            minQueryLength: this.props.minQueryLength,
            shouldRenderSuggestions: this.props.shouldRenderSuggestions,
            isFocused: this.state.isFocused,
            classNames,
            renderSuggestion: this.props.renderSuggestion
          }), clearAll && tags.length > 0 && _react["default"].createElement(_ClearAllTags["default"], {
            classNames,
            onClick: this.clearAll
          }), error && _react["default"].createElement("div", {
            "data-testid": "error",
            className: "ReactTags__error"
          }, _react["default"].createElement("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512",
            height: "24",
            width: "24",
            fill: "#e03131"
          }, _react["default"].createElement("path", {
            d: "M256 32c14.2 0 27.3 7.5 34.5 19.8l216 368c7.3 12.4 7.3 27.7 .2 40.1S486.3 480 472 480H40c-14.3 0-27.6-7.7-34.7-20.1s-7-27.8 .2-40.1l216-368C228.7 39.5 241.8 32 256 32zm0 128c-13.3 0-24 10.7-24 24V296c0 13.3 10.7 24 24 24s24-10.7 24-24V184c0-13.3-10.7-24-24-24zm32 224a32 32 0 1 0 -64 0 32 32 0 1 0 64 0z"
          })), error)) : null;
          return _react["default"].createElement("div", {
            className: (0, _classnames["default"])(classNames.tags, "react-tags-wrapper"),
            ref: this.reactTagsRef
          }, _react["default"].createElement("p", {
            role: "alert",
            className: "sr-only",
            style: {
              position: "absolute",
              overflow: "hidden",
              clip: "rect(0 0 0 0)",
              margin: "-1px",
              padding: 0,
              width: "1px",
              height: "1px",
              border: 0
            }
          }, this.state.ariaLiveStatus), position === _constants.INPUT_FIELD_POSITIONS.TOP && tagInput, _react["default"].createElement("div", {
            className: classNames.selected
          }, tagItems, position === _constants.INPUT_FIELD_POSITIONS.INLINE && tagInput), position === _constants.INPUT_FIELD_POSITIONS.BOTTOM && tagInput);
        }
      }]);
      return ReactTags2;
    }(_react.Component);
    _defineProperty26(ReactTags, "propTypes", {
      placeholder: _propTypes["default"].string,
      labelField: _propTypes["default"].string,
      suggestions: _propTypes["default"].arrayOf(_propTypes["default"].shape({
        id: _propTypes["default"].string.isRequired
      })),
      delimiters: _propTypes["default"].arrayOf(_propTypes["default"].number),
      autofocus: _propTypes["default"].bool,
      inline: _propTypes["default"].bool,
      // TODO: Remove in v7.x.x
      inputFieldPosition: _propTypes["default"].oneOf([_constants.INPUT_FIELD_POSITIONS.INLINE, _constants.INPUT_FIELD_POSITIONS.TOP, _constants.INPUT_FIELD_POSITIONS.BOTTOM]),
      handleDelete: _propTypes["default"].func,
      handleAddition: _propTypes["default"].func,
      onTagUpdate: _propTypes["default"].func,
      handleDrag: _propTypes["default"].func,
      handleFilterSuggestions: _propTypes["default"].func,
      handleTagClick: _propTypes["default"].func,
      allowDeleteFromEmptyInput: _propTypes["default"].bool,
      allowAdditionFromPaste: _propTypes["default"].bool,
      allowDragDrop: _propTypes["default"].bool,
      handleInputChange: _propTypes["default"].func,
      handleInputFocus: _propTypes["default"].func,
      handleInputBlur: _propTypes["default"].func,
      minQueryLength: _propTypes["default"].number,
      shouldRenderSuggestions: _propTypes["default"].func,
      removeComponent: _propTypes["default"].func,
      autocomplete: _propTypes["default"].oneOfType([_propTypes["default"].bool, _propTypes["default"].number]),
      readOnly: _propTypes["default"].bool,
      classNames: _propTypes["default"].object,
      name: _propTypes["default"].string,
      id: _propTypes["default"].string,
      maxLength: _propTypes["default"].number,
      inputValue: _propTypes["default"].string,
      maxTags: _propTypes["default"].number,
      tags: _propTypes["default"].arrayOf(_propTypes["default"].shape({
        id: _propTypes["default"].string.isRequired,
        className: _propTypes["default"].string
      })),
      allowUnique: _propTypes["default"].bool,
      renderSuggestion: _propTypes["default"].func,
      inputProps: _propTypes["default"].object,
      editable: _propTypes["default"].bool,
      clearAll: _propTypes["default"].bool,
      onClearAll: _propTypes["default"].func
    });
    _defineProperty26(ReactTags, "defaultProps", {
      placeholder: _constants.DEFAULT_PLACEHOLDER,
      labelField: _constants.DEFAULT_LABEL_FIELD,
      suggestions: [],
      delimiters: [].concat(_toConsumableArray2(_constants.KEYS.ENTER), [_constants.KEYS.TAB]),
      autofocus: true,
      inline: true,
      // TODO: Remove in v7.x.x
      inputFieldPosition: _constants.INPUT_FIELD_POSITIONS.INLINE,
      handleDelete: _noop["default"],
      handleAddition: _noop["default"],
      allowDeleteFromEmptyInput: true,
      allowAdditionFromPaste: true,
      autocomplete: false,
      readOnly: false,
      allowUnique: true,
      allowDragDrop: true,
      tags: [],
      inputProps: {},
      onTagUpdate: _noop["default"],
      editable: false,
      clearAll: false,
      handleClearAll: _noop["default"]
    });
    var WithContext = exports.WithContext = function WithContext2(_ref2) {
      var props = _extends({}, (_objectDestructuringEmpty(_ref2), _ref2));
      return _react["default"].createElement(_reactDnd.DndProvider, {
        backend: _reactDndHtml5Backend.HTML5Backend
      }, _react["default"].createElement(ReactTags, props));
    };
  }
});
export default require_ReactTags();
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)
*/
//# sourceMappingURL=react-tag-input.js.map
